# name: test/optimizer/compressed_materialization.test
# description: Compressed materialization test
# group: [optimizer]

statement ok
PRAGMA explain_output = OPTIMIZED_ONLY

# tricky tests taken from test/sql/subquery/scalar/test_issue_6136.test
statement ok
create table r as select * from values (1, 1, 'a', 'A'), (1, null, 'b', 'B'), (1, 2, 'c', 'C'), (2, null, 'd', 'D') t(ra, rb, x, y);

statement ok
create table b as select * from values (1, 1, 1), (2, 1, 2), (3, 1, 3), (4, 1, null), (5, 2, 1), (6, 2, null), (7, 99, 99) t(id, ba, bb);

query T
select (select {'x': first(x), 'y': first(y), '__matches': count(*)} from r where ba = ra and (bb = rb or rb is null) group by ra, rb)
from b
----
{'x': a, 'y': A, '__matches': 1}
{'x': c, 'y': C, '__matches': 1}
{'x': b, 'y': B, '__matches': 1}
{'x': b, 'y': B, '__matches': 1}
{'x': d, 'y': D, '__matches': 1}
{'x': d, 'y': D, '__matches': 1}
NULL

query T
select
  coalesce((select {'x': first(x), 'y': first(y), '__matches': count(*)} from r where ba = ra and (bb = rb or rb is null) group by ra, rb order by bb = rb), {'x': null, 'y': null, '__matches': 0}) as ref2
from b
----
{'x': b, 'y': B, '__matches': 1}
{'x': b, 'y': B, '__matches': 1}
{'x': b, 'y': B, '__matches': 1}
{'x': b, 'y': B, '__matches': 1}
{'x': d, 'y': D, '__matches': 1}
{'x': d, 'y': D, '__matches': 1}
{'x': NULL, 'y': NULL, '__matches': 0}

statement ok
create table test as
select (range + 7) % 4 i,
       (range + 7) % 11 j
from range(10)

# should see compress exactly twice (for columns i and j)
# if we see less than twice we're not compressing,
# and if we see it more than twice we're likely compressing and decompressing twice (once for each ORDER BY)
# but we can compress once, then do both ORDER BYs, then decompress
query II
explain select count(i), count(j) from (select i, j from (select i, j from test order by j offset 1) order by j offset 1)
----
logical_opt	<REGEX>:(.*__internal_compress.*){2}

# should see it exactly once here, as we can only compress the group (i), not the value being summed (j)
# after the GROUP BY we do the ORDER BY, and finally decompress
query II
explain select i, sum(j) from test group by i order by i
----
logical_opt	<REGEX>:(.*__internal_compress.*){1}

require tpch

statement ok
call dbgen(sf=0.01)

statement ok
PRAGMA explain_output = PHYSICAL_ONLY

# tpch q1 should use perfect hash aggregate
query II
EXPLAIN
SELECT
    l_returnflag,
    l_linestatus,
    sum(l_quantity) AS sum_qty,
    sum(l_extendedprice) AS sum_base_price,
    sum(l_extendedprice * (1 - l_discount)) AS sum_disc_price,
    sum(l_extendedprice * (1 - l_discount) * (1 + l_tax)) AS sum_charge,
    avg(l_quantity) AS avg_qty,
    avg(l_extendedprice) AS avg_price,
    avg(l_discount) AS avg_disc,
    count(*) AS count_order
FROM
    lineitem
WHERE
    l_shipdate <= CAST('1998-09-02' AS date)
GROUP BY
    l_returnflag,
    l_linestatus
ORDER BY
    l_returnflag,
    l_linestatus;
----
physical_plan	<REGEX>:.*PERFECT_HASH_GROUP_BY.*

statement ok
PRAGMA explain_output = OPTIMIZED_ONLY

# test that we're compressing lineitem
query II
explain select * from lineitem order by l_shipdate
----
logical_opt	<REGEX>:.*__internal_decompress.*__internal_compress.*

# test that we get the same result with and without compressed materialization
query IIIIIIIIIIIIIII nosort q0
select * from lineitem order by l_shipdate
----

statement ok
set disabled_optimizers to 'compressed_materialization'

query IIIIIIIIIIIIIII nosort q0
select * from lineitem order by l_shipdate
----
