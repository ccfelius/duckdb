# name: test/sql/upsert/upsert_conflict_in_different_chunk.test
# group: [upsert]

# breaks with constant verification
require no_vector_verification

statement ok
PRAGMA enable_verification;

statement ok
SET threads=1;

statement ok
CREATE TABLE create_or_replace(
	i BIGINT PRIMARY KEY,
	s VARCHAR
);

statement ok
CREATE TABLE inserts (
	i BIGINT,
	s VARCHAR
);

statement ok
INSERT INTO inserts VALUES
	(1, 'hello'),
	(1, 'world');

statement ok
INSERT OR REPLACE INTO create_or_replace
SELECT
	i,
	s
FROM inserts;

statement ok
DELETE FROM inserts;

statement ok
INSERT INTO inserts (
	SELECT
		range,
		'hello'
	FROM range(2050) UNION
	SELECT
		1,
		'world'
	);

# We can perform on-conflict handling in a different chunk. Appending duplicated values with INSERT OR REPLACE in the
# same statement/transaction is currently not officially supported (known limitations).
# We fix it for this case, as we introduced changes in https://github.com/duckdb/duckdb/pull/7407 that would
# otherwise throw an InternalException in the segment tree: https://github.com/duckdb/duckdb/issues/11924.

# This *was* fixed because the previous statement errored (introducing a conflicting tuple in the same Vector)
# But that is now fixed, so this is now attempting to update the same existing row_id twice, once in the first chunk and once in the second
# which is explicitly not allowed.

# Previously this was inserting a tuple into transaction-local storage and then updating that tuple in the next chunk, which *is* allowed.
statement error
INSERT OR REPLACE INTO create_or_replace SELECT i, s FROM inserts;
----
ON CONFLICT DO UPDATE can not update the same row twice in the same command. Ensure that no rows proposed for insertion within the same command have duplicate constrained values

query II
FROM create_or_replace WHERE s != 'hello';
----
1	world
