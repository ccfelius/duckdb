# name: test/sql/function/list/lambdas/transform.test
# description: Test list_transform function
# group: [lambdas]

# NOTE: some of these tests are directly taken from the Presto Array Function examples

# lambda parameter has the same name as a column

statement ok
CREATE TABLE l_test (l integer[])

statement error
SELECT l, list_transform(l, l -> l + 1) FROM l_test

query II
SELECT [1] AS l, list_transform([1], l -> l + 1)
----
[1]	[2]

# test NULLs and simple cases

query I
SELECT list_transform(NULL, x -> x + 1)
----
NULL

query I
SELECT list_transform([1], x -> x)
----
[1]

query I
SELECT list_transform(['duck', 'a', 'ö'], duck -> concat(duck, 'DB'))
----
[duckDB, aDB, öDB]

query I
SELECT list_transform([1, 2, 3], x -> 1)
----
[1, 1, 1]

query I
SELECT list_transform([], x -> x + 1)
----
[]

query I
SELECT list_transform([1, 2, 3], x -> x + 1)
----
[2, 3, 4]

query I
SELECT list_transform([1, NULL, -2, NULL], x -> x + 1)
----
[2, NULL, -1, NULL]

# test on table with rows

statement ok
CREATE TABLE lists (n integer, l integer[])

statement ok
INSERT INTO lists VALUES (1, [1]), (2, [1, 2, 3]), (3, NULL), (4, [-1, NULL, 2])

query I
SELECT list_transform(l, x -> x) FROM lists
----
[1]
[1, 2, 3]
NULL
[-1, NULL, 2]

query I
SELECT list_transform(l, x -> x + n) FROM lists
----
[2]
[3, 4, 5]
NULL
[3, NULL, 6]

query I
SELECT list_transform(l, x -> x < 2) FROM lists
----
[True]
[True, False, False]
NULL
[True, NULL, False]

# test other operators and more complex/nested functions

query I
SELECT list_transform(['x', 'abc', 'z'], x -> x || '0')
----
[x0, abc0, z0]

query I
SELECT list_transform([[1], [2, 3], [NULL], NULL], x -> list_transform(x, y -> y + 1))
----
[[2], [3, 4], [NULL], NULL]

query I
SELECT list_transform([[1], [2], [3]], x -> list_concat(x, x))
----
[[1, 1], [2, 2], [3, 3]]

query I
SELECT list_transform([5, NULL, 6], x -> POW(x, 2))
----
[25.000000, NULL, 36.000000]

query I
SELECT list_transform([5, NULL, 6], x -> COALESCE(x, 0) + 1)
----
[6, 1, 7]

query I
SELECT list_transform(list_value(list_unique(list_concat([1,2],[2,2]))), x -> x + 1);
----
[3.000000]

query I
SELECT list_sort(list_transform(list_distinct(list_concat([1,2],[2,2])), x -> x + 1));
----
[2, 3]

query I
SELECT list_transform([[1], [2], [3]], x -> list_concat(list_transform(x, y -> y + 1), list_transform(x, z -> z - 1)))
----
[[2, 0], [3, 1], [4, 2]]

query I
SELECT list_transform([[1], [4], NULL, [1], [8]], x -> list_concat(list_transform(x, y -> CASE WHEN y > 1 THEN 'yay' ELSE 'nay' END), x))
----
[[nay, 1], [yay, 4], NULL, [nay, 1], [yay, 8]]

# test aliases

query I
SELECT array_transform([1, NULL], arr_elem -> arr_elem - 4)
----
[-3, NULL]

query I
SELECT array_apply([1, NULL], arr_elem -> arr_elem - 4)
----
[-3, NULL]

query I
SELECT list_apply([1, NULL], arr_elem -> arr_elem - 4)
----
[-3, NULL]

statement error
select list_apply(i, x -> x * 3 + 2 / zz) from (values (list_value(1, 2, 3))) tbl(i);

# lambda cannot be the root of a plan
statement error
select x -> x + 1 from (values (list_value(1, 2, 3))) tbl(i);

# lhs of lambda must be an unqualified column name
statement error
select list_apply(i, y + 1 -> x + 1) from (values (list_value(1, 2, 3))) tbl(i);

statement error
select list_apply(i, a.x -> x + 1) from (values (list_value(1, 2, 3))) tbl(i);

# more tests on precedence

query I
select list_apply(i, x -> (6 + 2 * 12) / x) from (values (list_value(1, 2, 3))) tbl(i);
----
[30, 15, 10]

query I
select list_apply(i, x -> x + 1 AND x + 1) from (values (list_value(1, 2, 3))) tbl(i);
----
[True, True, True]

statement error
select list_apply(i, x -> x + 1 AND y + 1) from (values (list_value(1, 2, 3))) tbl(i);