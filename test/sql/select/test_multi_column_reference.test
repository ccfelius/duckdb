# name: test/sql/select/test_multi_column_reference.test
# description: Test multi column reference
# group: [select]

statement ok
PRAGMA enable_verification

# column names can have an arbitrary amount of dots
# here is how the resolution works:
# no dots (i.e. "part1")
# -> part1 refers to a column
# one dot (i.e. "part1.part2")
# EITHER:
# -> part1 is a table, part2 is a column
# -> part1 is a column, part2 is a property of that column (i.e. struct_extract)
# two or more dots (i.e. "part1.part2.part3.part4...")
# -> part1 is a schema, part2 is a table, part3 is a column name, part4 and beyond are struct fields
# -> part1 is a table, part2 is a column name, part3 and beyond are struct fields
# -> part1 is a column, part2 and beyond are struct fields

# we always prefer the most top-level view
# i.e. in case of multiple resolution options, we resolve in order:
# -> 1. resolve "part1" as a schema
# -> 2. resolve "part1" as a table
# -> 3. resolve "part1" as a column

# schema -> table -> column reference
statement ok
CREATE SCHEMA test

statement ok
CREATE TABLE test.tbl(col INTEGER);

statement ok
INSERT INTO test.tbl VALUES (1), (2), (3);

query I
SELECT test.tbl.col FROM test.tbl;
----
1
2
3

# check how ties are resolved
# we create a table called "t" in a schema called "t" with a column called "t" that has a field called "t"
statement ok
CREATE SCHEMA t

statement ok
CREATE TABLE t.t(t ROW(t INTEGER));

statement ok
INSERT INTO t.t VALUES ({'t': 42});

# "t" selects the column
query I
SELECT t FROM t.t;
----
{'t': 42}

# "t.t" also selects the column
query I
SELECT t.t FROM t.t;
----
{'t': 42}

# t.t.t also selects the column
query I
SELECT t.t.t FROM t.t;
----
{'t': 42}

# t.t.t.t selects the field
query I
SELECT t.t.t.t FROM t.t;
----
42

# test failures
statement error
SELECT testX.tbl.col FROM test.tbl;

statement error
SELECT test.tblX.col FROM test.tbl;

statement error
SELECT test.tbl.colX FROM test.tbl;

# nested structs with very long chains
# multiple tables with the same name but a different schema?
# schema name with alias?
# CHECK on struct CHECK(x.a)
# ALTER TYPE with struct (x.a)
