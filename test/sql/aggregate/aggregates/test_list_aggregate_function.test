# name: test/sql/aggregate/aggregates/test_list_aggregate_function.test
# description: Test the list aggregate function for all data types
# group: [aggregates]

# TODO: NULLs

# INTEGER types

foreach type tinyint smallint integer bigint utinyint usmallint uinteger ubigint

statement ok
CREATE TABLE test (g INTEGER, i ${type})

statement ok
INSERT INTO test VALUES (1, 2), (1, 3), (2, 4)

query I
SELECT LIST(i) FROM test GROUP BY g ORDER BY g
----
[2, 3]
[4]

statement ok
DROP TABLE test

endloop

# FLOAT, DOUBLE

foreach type float double

statement ok
CREATE TABLE test (g INTEGER, i ${type})

statement ok
INSERT INTO test VALUES (1, 2), (1, 3), (2, 4)

query I
SELECT LIST(i) FROM test GROUP BY g ORDER BY g
----
[2.0, 3.0]
[4.0]

statement ok
DROP TABLE test

endloop

# one level nested LIST

statement ok
CREATE TABLE nested_lists (g INTEGER, i INTEGER[])

statement ok
INSERT INTO nested_lists VALUES (1, [2]), (1, [3]), (2, [4])

query I
SELECT LIST(i) FROM nested_lists GROUP BY g ORDER BY g
----
[[2], [3]]
[[4]]

# TODO: incorrect/not implemented
# TODO: hugeint, or should that be supported?

# bigger lists than standard vector size

statement ok
CREATE TABLE bigger_lists AS SELECT range % 4 g, range i FROM range(100000)

query I
SELECT list_count(LIST(i)) FROM bigger_lists GROUP BY g ORDER BY g
----
25000
25000
25000
25000

# many groups with small lists

statement ok
CREATE TABLE lists AS SELECT range % 10000 g, range i FROM range(100000);

query I
SELECT list_count(LIST(i)) FROM lists GROUP BY g ORDER BY g LIMIT 2;
----
10
10

# structs

statement ok
CREATE TABLE structs AS SELECT 1 AS g, {'x': 3, 'b': 2} AS s

statement ok
INSERT INTO structs VALUES (1, {'x': 5, 'b': 4}), (2, {'x': 50, 'b': 40})

query I
SELECT LIST(s) FROM structs GROUP BY g ORDER BY g
----
[{'x': 3, 'b': 2}, {'x': 5, 'b': 4}]
[{'x': 50, 'b': 40}]