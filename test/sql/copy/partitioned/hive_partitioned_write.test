# name: test/sql/copy/partitioned/hive_partitioned_write.test
# description: basic tests for the hive partitioned write
# group: [partitioned]

require parquet

# Simple table that is easy to partition
statement ok
CREATE TABLE test as SELECT i%2 as part_col, (i+1)%5 as value_col, i as value2_col from range(0,10) tbl(i);

statement ok
COPY test TO '__TEST_DIR__/partitioned1' (FORMAT PARQUET, PARTITION_BY (part_col));

query III
SELECT part_col, value_col, value2_col FROM '__TEST_DIR__/partitioned1/part_col=0/*.parquet' ORDER BY value2_col;
----
0	1	0
0	3	2
0	0	4
0	2	6
0	4	8

query III
SELECT part_col, value_col, value2_col FROM '__TEST_DIR__/partitioned1/part_col=1/*.parquet' ORDER BY value2_col;
----
1	2	1
1	4	3
1	1	5
1	3	7
1	0	9

# Want a modified version of the partition_col? (for example to do custom string conversion?) No problem:
statement ok
COPY (SELECT * EXCLUDE (part_col), 'prefix-'::VARCHAR || part_col::VARCHAR as part_col FROM test) TO '__TEST_DIR__/partitioned2' (FORMAT PARQUET, PARTITION_BY (part_col));

query III
SELECT part_col, value_col, value2_col FROM '__TEST_DIR__/partitioned2/part_col=prefix-0/*.parquet' ORDER BY value2_col;
----
prefix-0	1	0
prefix-0	3	2
prefix-0	0	4
prefix-0	2	6
prefix-0	4	8

query III
SELECT part_col, value_col, value2_col FROM '__TEST_DIR__/partitioned2/part_col=prefix-1/*.parquet' ORDER BY value2_col;
----
prefix-1	2	1
prefix-1	4	3
prefix-1	1	5
prefix-1	3	7
prefix-1	0	9

# Test partitioning by all
statement ok
COPY test TO '__TEST_DIR__/partitioned3' (FORMAT PARQUET, PARTITION_BY '*');

query I
SELECT min(value2_col) as min_val
FROM parquet_scan('__TEST_DIR__/partitioned3/part_col=*/value_col=*/value2_col=*/*.parquet', FILENAME=1)
GROUP BY filename
ORDER BY min_val
----
0
1
2
3
4
5
6
7
8
9

# single col as param is also fine
statement ok
COPY test TO '__TEST_DIR__/partitioned4' (FORMAT PARQUET, PARTITION_BY part_col);

query III
SELECT part_col, value_col, value2_col FROM parquet_scan('__TEST_DIR__/partitioned4/part_col=*/*.parquet', HIVE_PARTITIONING=1) WHERE part_col=0 ORDER BY value2_col;
----
0	1	0
0	3	2
0	0	4
0	2	6
0	4	8


# a file already exist, throw error
statement error
COPY test TO '__TEST_DIR__/partitioned4' (FORMAT PARQUET, PARTITION_BY part_col);
----
Directory

# Trailing slash ist auch gut!
statement ok
COPY test TO '__TEST_DIR__/partitioned5/' (FORMAT PARQUET, PARTITION_BY part_col);

query III
SELECT part_col, value_col, value2_col FROM '__TEST_DIR__/partitioned5/part_col=0/*.parquet' ORDER BY value2_col;
----
0	1	0
0	3	2
0	0	4
0	2	6
0	4	8

# Cannot use the USE_TMP_FILE option simulatiously with partitioning
statement error
COPY test TO '__TEST_DIR__/partitioned6' (FORMAT PARQUET, PARTITION_BY part_col, USE_TMP_FILE TRUE);
----
Not implemented Error: Can't combine USE_TMP_FILE and PARTITION_BY for COPY

# Technically it doesn't really matter, as currently out parition_by behaves similarly, but for clarity user should just
# EITHER use partition_by or per_thread_output.
statement error
COPY test TO '__TEST_DIR__/partitioned6' (FORMAT PARQUET, PARTITION_BY part_col, PER_THREAD_OUTPUT TRUE);
----
Not implemented Error: Can't combine PER_THREAD_OUTPUT and PARTITION_BY for COPY

# partitioning csv files is also a thing
statement ok
COPY test TO '__TEST_DIR__/partitioned7' (FORMAT CSV, PARTITION_BY part_col);

query III
SELECT part_col, value_col, value2_col FROM '__TEST_DIR__/partitioned7/part_col=0/*.csv' ORDER BY value2_col;
----
0	1	0
0	3	2
0	0	4
0	2	6
0	4	8

query III
SELECT part_col, value_col, value2_col FROM '__TEST_DIR__/partitioned7/part_col=1/*.csv' ORDER BY value2_col;
----
1	2	1
1	4	3
1	1	5
1	3	7
1	0	9

# Don't care about capitalization
statement ok
COPY test TO '__TEST_DIR__/partitioned8' (FORMAT PARQUET, PARTITION_BY pArt_cOl);

query III
SELECT part_col, value_col, value2_col FROM '__TEST_DIR__/partitioned8/part_col=0/*.parquet' ORDER BY value2_cOl;
----
0	1	0
0	3	2
0	0	4
0	2	6
0	4	8

# Order matters!
statement ok
COPY test TO '__TEST_DIR__/partitioned9' (FORMAT PARQUET, PARTITION_BY (part_col, value_col));

query I
SELECT min(value2_col) as min_val
FROM parquet_scan('__TEST_DIR__/partitioned9/part_col=*/value_col=*/*.parquet', FILENAME=1)
GROUP BY filename
ORDER BY min_val
----
0
1
2
3
4
5
6
7
8
9

statement ok
COPY test TO '__TEST_DIR__/partitioned10' (FORMAT PARQUET, PARTITION_BY (value_col, part_col));

query I
SELECT min(value2_col) as min_val
FROM parquet_scan('__TEST_DIR__/partitioned10/value_col=*/part_col=*/*.parquet', FILENAME=1)
GROUP BY filename
ORDER BY min_val
----
0
1
2
3
4
5
6
7
8
9

# Skip partition column writes for Parquet format with NO_PARTITION_COLUMNS option (issue 11931 & 12147)
# SELECT query returns all columns, but written files do not have partition columns
statement ok
COPY test TO '__TEST_DIR__/partitioned11' (FORMAT PARQUET, PARTITION_BY (part_col), NO_PARTITION_COLUMNS);

query III
SELECT part_col, value_col, value2_col FROM '__TEST_DIR__/partitioned11/part_col=0/*.parquet' ORDER BY value2_col;
----
0	1	0
0	3	2
0	0	4
0	2	6
0	4	8

# Skip writes of 2 partition columns
statement ok
COPY test TO '__TEST_DIR__/partitioned12' (FORMAT PARQUET, PARTITION_BY (part_col, value_col), NO_PARTITION_COLUMNS);

query III
SELECT part_col, value_col, value2_col FROM '__TEST_DIR__/partitioned12/part_col=0/value_col=*/*.parquet' ORDER BY value2_col;
----
0	1	0
0	3	2
0	0	4
0	2	6
0	4	8

# Modified version of the partition_col with NO_PARTITION_COLUMNS 
statement ok
COPY (SELECT * EXCLUDE (part_col), 'prefix-'::VARCHAR || part_col::VARCHAR as part_col FROM test) TO '__TEST_DIR__/partitioned13' (FORMAT PARQUET, PARTITION_BY (part_col), NO_PARTITION_COLUMNS);

query III
SELECT part_col, value_col, value2_col FROM '__TEST_DIR__/partitioned13/part_col=prefix-0/*.parquet' ORDER BY value2_col;
----
prefix-0	1	0
prefix-0	3	2
prefix-0	0	4
prefix-0	2	6
prefix-0	4	8

# Partitions of more than 8 columns with NO_PARTITION_COLUMNS option
statement ok
COPY (SELECT 1 AS part_col, 2 AS value_col, 3 AS value2_col, 4 AS value3_col, 5 AS value4_col, 6 AS value5_col, 7 AS value6_col, 8 AS value7_col, 9 AS value8_col, 10 AS value9_col) TO '__TEST_DIR__/partitioned14' (FORMAT PARQUET, PARTITION_BY (part_col), NO_PARTITION_COLUMNS 1);

query IIIIIIIIII
SELECT part_col, value_col, value2_col, value3_col, value4_col, value5_col, value6_col, value7_col, value8_col, value9_col FROM '__TEST_DIR__/partitioned14/part_col=1/*.parquet' ORDER BY 1;
----
1	2	3	4	5	6	7	8	9	10

# Partition by last column out of 10 columns with NO_PARTITION_COLUMNS option
statement ok
COPY (SELECT 1 AS part_col, 2 AS value_col, 3 AS value2_col, 4 AS value3_col, 5 AS value4_col, 6 AS value5_col, 7 AS value6_col, 8 AS value7_col, 9 AS value8_col, 10 AS value9_col) TO '__TEST_DIR__/partitioned15' (FORMAT PARQUET, PARTITION_BY (value9_col), NO_PARTITION_COLUMNS 1);

query IIIIIIIIII
SELECT part_col, value_col, value2_col, value3_col, value4_col, value5_col, value6_col, value7_col, value8_col, value9_col FROM '__TEST_DIR__/partitioned15/value9_col=*/*.parquet' ORDER BY 1;
----
1	2	3	4	5	6	7	8	9	10

# Partition by last 2 columns out of 10 columns with NO_PARTITION_COLUMNS option
statement ok
COPY (SELECT 1 AS part_col, 2 AS value_col, 3 AS value2_col, 4 AS value3_col, 5 AS value4_col, 6 AS value5_col, 7 AS value6_col, 8 AS value7_col, 9 AS value8_col, 10 AS value9_col) TO '__TEST_DIR__/partitioned16' (FORMAT PARQUET, PARTITION_BY (value8_col, value9_col), NO_PARTITION_COLUMNS 1);

query IIIIIIIIII
SELECT part_col, value_col, value2_col, value3_col, value4_col, value5_col, value6_col, value7_col, value8_col, value9_col FROM '__TEST_DIR__/partitioned16/value8_col=*/value9_col=*/*.parquet' ORDER BY 1;
----
1	2	3	4	5	6	7	8	9	10

# Partition by last 3 columns out of 10 columns in a reverse order with NO_PARTITION_COLUMNS option
statement ok
COPY (SELECT 1 AS part_col, 2 AS value_col, 3 AS value2_col, 4 AS value3_col, 5 AS value4_col, 6 AS value5_col, 7 AS value6_col, 8 AS value7_col, 9 AS value8_col, 10 AS value9_col) TO '__TEST_DIR__/partitioned17' (FORMAT PARQUET, PARTITION_BY (value9_col, value8_col, value7_col), NO_PARTITION_COLUMNS 1);

query IIIIIIIIII
SELECT part_col, value_col, value2_col, value3_col, value4_col, value5_col, value6_col, value7_col, value8_col, value9_col FROM '__TEST_DIR__/partitioned17/value9_col=*/value8_col=*/value7_col=*/*.parquet' ORDER BY 1;
----
1	2	3	4	5	6	7	8	9	10

# Throw error if there's no column to write by skipping partition column writes
statement error
COPY test TO '__TEST_DIR__/partitioned' (FORMAT PARQUET, PARTITION_BY (part_col, value_col, value2_col), NO_PARTITION_COLUMNS);
----
Not implemented Error: There is no column to write due to PARTITION_BY and NO_PARTITION_COLUMNS options.

statement error
COPY test TO '__TEST_DIR__/partitioned' (FORMAT PARQUET, PARTITION_BY '*', NO_PARTITION_COLUMNS);
----
Not implemented Error: There is no column to write due to PARTITION_BY and NO_PARTITION_COLUMNS options.
