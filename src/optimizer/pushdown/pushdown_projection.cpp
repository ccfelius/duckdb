#include "duckdb/optimizer/filter_pushdown.hpp"
#include "duckdb/planner/expression/bound_columnref_expression.hpp"
#include "duckdb/planner/expression_iterator.hpp"
#include "duckdb/planner/operator/logical_empty_result.hpp"
#include "duckdb/planner/operator/logical_projection.hpp"

namespace duckdb {

static bool IsVolatile(LogicalProjection &proj, const unique_ptr<Expression> &expr) {
	if (expr->type == ExpressionType::BOUND_COLUMN_REF) {
		auto &colref = expr->Cast<BoundColumnRefExpression>();
		D_ASSERT(colref.binding.table_index == proj.table_index);
		D_ASSERT(colref.binding.column_index < proj.expressions.size());
		D_ASSERT(colref.depth == 0);
		if (proj.expressions[colref.binding.column_index]->IsVolatile()) {
			return true;
		}
		return false;
	}
	bool is_volatile = false;
	ExpressionIterator::EnumerateChildren(
	    *expr, [&](unique_ptr<Expression> &child) { is_volatile |= IsVolatile(proj, child); });
	return is_volatile;
}

static unique_ptr<Expression> ReplaceProjectionBindings(LogicalProjection &proj, unique_ptr<Expression> expr) {
	if (expr->type == ExpressionType::BOUND_COLUMN_REF) {
		auto &colref = expr->Cast<BoundColumnRefExpression>();
		D_ASSERT(colref.binding.table_index == proj.table_index);
		D_ASSERT(colref.binding.column_index < proj.expressions.size());
		D_ASSERT(colref.depth == 0);
		// replace the binding with a copy to the expression at the referenced index
		return proj.expressions[colref.binding.column_index]->Copy();
	}
	ExpressionIterator::EnumerateChildren(
	    *expr, [&](unique_ptr<Expression> &child) { child = ReplaceProjectionBindings(proj, std::move(child)); });
	return expr;
}

bool FilterPushdown::FilterInputsChangeTypes(unique_ptr<Expression> filter,
                                             vector<unique_ptr<Expression>> &expressions) {
	// iterate through expressions of the filter and gather the columns the filter performs on
	unordered_set<idx_t> columns;
	ExpressionIterator::EnumerateExpression(filter, [&](Expression &child) {
		switch (child.expression_class) {
		case ExpressionClass::BOUND_COLUMN_REF: {
			auto &colref = child.Cast<BoundColumnRefExpression>();
			columns.insert(colref.binding.column_index);
			break;
		}
		default:
			break;
		}
	});

	D_ASSERT(columns.size() <= expressions.size());

	// go through the projected columns in the filter, if a column has a cast it is changing types
	// from what it was below the projection. That means we cannot push this filter down.
	bool to_return = false;
	for (auto &column : columns) {
		auto &proj_expr = expressions.at(column);
		ExpressionIterator::EnumerateExpression(proj_expr, [&](Expression &child) {
			switch (child.expression_class) {
			case ExpressionClass::BOUND_CAST: {
				auto &cast = child.Cast<BoundCastExpression>();
				// if the max logical type is what is being cast to, then you can push down the filter.
				// i.e if you are casting from int to varchar, every int value can cast to varchar, so you can push the
				// filter down if you cast from varchar to int, there may be reason to not push the filter down, as
				// another filter will filter out varchar values that cannot be cast to int). See
				// test_no_pushdown_cast.test
				if (LogicalType::ForceMaxLogicalType(cast.return_type.id(), cast.child->return_type.id()).id() ==
				    cast.child->return_type.id()) {
					to_return = true;
				}
				break;
			}
			default:
				break;
			}
		});
		if (to_return) {
			break;
		}
	}

	return to_return;
}

unique_ptr<LogicalOperator> FilterPushdown::PushdownProjection(unique_ptr<LogicalOperator> op) {
	D_ASSERT(op->type == LogicalOperatorType::LOGICAL_PROJECTION);
	auto &proj = op->Cast<LogicalProjection>();
	// push filter through logical projection
	// all the BoundColumnRefExpressions in the filter should refer to the LogicalProjection
	// we can rewrite them by replacing those references with the expression of the LogicalProjection node
	FilterPushdown child_pushdown(optimizer, convert_mark_joins);
	// There are some expressions can not be pushed down. We should keep them
	// and add an extra filter operator.
	vector<unique_ptr<Expression>> remain_expressions;
	for (auto &filter : filters) {
		auto &f = *filter;
		D_ASSERT(f.bindings.size() <= 1);
		bool is_volatile = IsVolatile(proj, f.filter);
		if (is_volatile || FilterInputsChangeTypes(f.filter->Copy(), proj.expressions)) {
			// We can't push down related expressions if the column in the
			// expression is generated by the functions which have side effects
			remain_expressions.push_back(std::move(f.filter));
		} else {
			// rewrite the bindings within this subquery
			f.filter = ReplaceProjectionBindings(proj, std::move(f.filter));
			// add the filter to the child pushdown
			if (child_pushdown.AddFilter(std::move(f.filter)) == FilterResult::UNSATISFIABLE) {
				// filter statically evaluates to false, strip tree
				return make_uniq<LogicalEmptyResult>(std::move(op));
			}
		}
	}
	child_pushdown.GenerateFilters();
	// now push into children
	op->children[0] = child_pushdown.Rewrite(std::move(op->children[0]));
	if (op->children[0]->type == LogicalOperatorType::LOGICAL_EMPTY_RESULT) {
		// child returns an empty result: generate an empty result here too
		return make_uniq<LogicalEmptyResult>(std::move(op));
	}
	return AddLogicalFilter(std::move(op), std::move(remain_expressions));
}

} // namespace duckdb
