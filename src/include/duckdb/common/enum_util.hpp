//-------------------------------------------------------------------------
// This file is automatically generated by scripts/generate_enum_util.py
// Do not edit this file manually, your changes will be overwritten
// If you want to exclude an enum from serialization, add it to the blacklist in the script
//
// Note: The generated code will only work properly if the enum is a top level item in the duckdb namespace
// If the enum is nested in a class, or in another namespace, the generated code will not compile.
// You should move the enum to the duckdb namespace, manually write a specialization or add it to the blacklist
//-------------------------------------------------------------------------

#pragma once

#include <stdint.h>

namespace duckdb {

struct EnumUtil {
	// String -> Enum
	template <class T>
	static T StringToEnum(const char *value) = delete;

	// Enum -> String
	template <class T>
	static const char *EnumToString(T value) = delete;
};

enum class TaskExecutionMode : uint8_t;

enum class TaskExecutionResult : uint8_t;

enum class DistinctType : uint8_t;

enum class TableFilterType : uint8_t;

enum class BindingMode : uint8_t;

enum class TableColumnType : uint8_t;

enum class AggregateType : uint8_t;

enum class AggregateOrderDependent : uint8_t;

enum class FunctionNullHandling : uint8_t;

enum class FunctionSideEffects : uint8_t;

enum class MacroType : uint8_t;

enum class ArrowVariableSizeType : uint8_t;

enum class ArrowDateTimeType : uint8_t;

enum class StrTimeSpecifier : uint8_t;

enum class SimplifiedTokenType : uint8_t;

enum class KeywordCategory : uint8_t;

enum class ResultModifierType : uint8_t;

enum class ConstraintType : uint8_t;

enum class ForeignKeyType : uint8_t;

enum class ParserExtensionResultType : uint8_t;

enum class QueryNodeType : uint8_t;

enum class SequenceInfo : uint8_t;

enum class AlterScalarFunctionType : uint8_t;

enum class AlterTableType : uint8_t;

enum class AlterViewType : uint8_t;

enum class AlterTableFunctionType : uint8_t;

enum class AlterType : uint8_t;

enum class PragmaType : uint8_t;

enum class OnCreateConflict : uint8_t;

enum class TransactionType : uint8_t;

enum class SampleMethod : uint8_t;

enum class ExplainType : uint8_t;

enum class OnConflictAction : uint8_t;

enum class WindowBoundary : uint8_t;

enum class DataFileType : uint8_t;

enum class StatsInfo : uint8_t;

enum class StatisticsType : uint8_t;

enum class ColumnSegmentType : uint8_t;

enum class ChunkInfoType : uint8_t;

enum class BitpackingMode : uint8_t;

enum class BlockState : uint8_t;

enum class VerificationType : uint8_t;

enum class FileLockType : uint8_t;

enum class FileBufferType : uint8_t;

enum class ExceptionFormatValueType : uint8_t;

enum class ExtraTypeInfoType : uint8_t;

enum class PhysicalType : uint8_t;

enum class LogicalTypeId : uint8_t;

enum class OutputStream : uint8_t;

enum class TimestampCastResult : uint8_t;

enum class ConflictManagerMode : uint8_t;

enum class LookupResultType : uint8_t;

enum class MapInvalidReason : uint8_t;

enum class UnionInvalidReason : uint8_t;

enum class VectorBufferType : uint8_t;

enum class VectorAuxiliaryDataType : uint8_t;

enum class PartitionedColumnDataType : uint8_t;

enum class ColumnDataAllocatorType : uint8_t;

enum class ColumnDataScanProperties : uint8_t;

enum class PartitionedTupleDataType : uint8_t;

enum class TupleDataPinProperties : uint8_t;

enum class PartitionSortStage : uint8_t;

enum class PhysicalOperatorType : uint8_t;

enum class VectorType : uint8_t;

enum class AccessMode : uint8_t;

enum class FileGlobOptions : uint8_t;

enum class WALType : uint8_t;

enum class JoinType : uint8_t;

enum class FileCompressionType : uint8_t;

enum class ProfilerPrintFormat : uint8_t;

enum class StatementType : uint8_t;

enum class StatementReturnType : uint8_t;

enum class OrderPreservationType : uint8_t;

enum class DebugInitialize : uint8_t;

enum class CatalogType : uint8_t;

enum class SetScope : uint8_t;

enum class TableScanType : uint8_t;

enum class SetType : uint8_t;

enum class ExpressionType : uint8_t;

enum class ExpressionClass : uint8_t;

enum class PendingExecutionResult : uint8_t;

enum class WindowAggregationMode : uint32_t;

enum class SubqueryType : uint8_t;

enum class OrderType : uint8_t;

enum class OrderByNullType : uint8_t;

enum class DefaultOrderByNullType : uint8_t;

enum class DatePartSpecifier : uint8_t;

enum class OnEntryNotFound : uint8_t;

enum class LogicalOperatorType : uint8_t;

enum class OperatorResultType : uint8_t;

enum class OperatorFinalizeResultType : uint8_t;

enum class SinkResultType : uint8_t;

enum class SinkFinalizeType : uint8_t;

enum class JoinRefType : uint8_t;

enum class UndoFlags : uint32_t;

enum class SetOperationType : uint8_t;

enum class OptimizerType : uint32_t;

enum class CompressionType : uint8_t;

enum class AggregateHandling : uint8_t;

enum class TableReferenceType : uint8_t;

enum class RelationType : uint8_t;

enum class FilterPropagateResult : uint8_t;

enum class IndexType : uint8_t;

enum class ExplainOutputType : uint8_t;

enum class NType : uint8_t;

enum class VerifyExistenceType : uint8_t;

enum class ParserMode : uint8_t;

enum class ErrorType : uint16_t;

enum class AppenderType : uint8_t;

enum class CheckpointAbort : uint8_t;

enum class ExtensionLoadResult : uint8_t;

enum class QueryResultType : uint8_t;

enum class CAPIResultSetType : uint8_t;

template <>
const char *EnumUtil::EnumToString<TaskExecutionMode>(TaskExecutionMode value);

template <>
const char *EnumUtil::EnumToString<TaskExecutionResult>(TaskExecutionResult value);

template <>
const char *EnumUtil::EnumToString<DistinctType>(DistinctType value);

template <>
const char *EnumUtil::EnumToString<TableFilterType>(TableFilterType value);

template <>
const char *EnumUtil::EnumToString<BindingMode>(BindingMode value);

template <>
const char *EnumUtil::EnumToString<TableColumnType>(TableColumnType value);

template <>
const char *EnumUtil::EnumToString<AggregateType>(AggregateType value);

template <>
const char *EnumUtil::EnumToString<AggregateOrderDependent>(AggregateOrderDependent value);

template <>
const char *EnumUtil::EnumToString<FunctionNullHandling>(FunctionNullHandling value);

template <>
const char *EnumUtil::EnumToString<FunctionSideEffects>(FunctionSideEffects value);

template <>
const char *EnumUtil::EnumToString<MacroType>(MacroType value);

template <>
const char *EnumUtil::EnumToString<ArrowVariableSizeType>(ArrowVariableSizeType value);

template <>
const char *EnumUtil::EnumToString<ArrowDateTimeType>(ArrowDateTimeType value);

template <>
const char *EnumUtil::EnumToString<StrTimeSpecifier>(StrTimeSpecifier value);

template <>
const char *EnumUtil::EnumToString<SimplifiedTokenType>(SimplifiedTokenType value);

template <>
const char *EnumUtil::EnumToString<KeywordCategory>(KeywordCategory value);

template <>
const char *EnumUtil::EnumToString<ResultModifierType>(ResultModifierType value);

template <>
const char *EnumUtil::EnumToString<ConstraintType>(ConstraintType value);

template <>
const char *EnumUtil::EnumToString<ForeignKeyType>(ForeignKeyType value);

template <>
const char *EnumUtil::EnumToString<ParserExtensionResultType>(ParserExtensionResultType value);

template <>
const char *EnumUtil::EnumToString<QueryNodeType>(QueryNodeType value);

template <>
const char *EnumUtil::EnumToString<SequenceInfo>(SequenceInfo value);

template <>
const char *EnumUtil::EnumToString<AlterScalarFunctionType>(AlterScalarFunctionType value);

template <>
const char *EnumUtil::EnumToString<AlterTableType>(AlterTableType value);

template <>
const char *EnumUtil::EnumToString<AlterViewType>(AlterViewType value);

template <>
const char *EnumUtil::EnumToString<AlterTableFunctionType>(AlterTableFunctionType value);

template <>
const char *EnumUtil::EnumToString<AlterType>(AlterType value);

template <>
const char *EnumUtil::EnumToString<PragmaType>(PragmaType value);

template <>
const char *EnumUtil::EnumToString<OnCreateConflict>(OnCreateConflict value);

template <>
const char *EnumUtil::EnumToString<TransactionType>(TransactionType value);

template <>
const char *EnumUtil::EnumToString<SampleMethod>(SampleMethod value);

template <>
const char *EnumUtil::EnumToString<ExplainType>(ExplainType value);

template <>
const char *EnumUtil::EnumToString<OnConflictAction>(OnConflictAction value);

template <>
const char *EnumUtil::EnumToString<WindowBoundary>(WindowBoundary value);

template <>
const char *EnumUtil::EnumToString<DataFileType>(DataFileType value);

template <>
const char *EnumUtil::EnumToString<StatsInfo>(StatsInfo value);

template <>
const char *EnumUtil::EnumToString<StatisticsType>(StatisticsType value);

template <>
const char *EnumUtil::EnumToString<ColumnSegmentType>(ColumnSegmentType value);

template <>
const char *EnumUtil::EnumToString<ChunkInfoType>(ChunkInfoType value);

template <>
const char *EnumUtil::EnumToString<BitpackingMode>(BitpackingMode value);

template <>
const char *EnumUtil::EnumToString<BlockState>(BlockState value);

template <>
const char *EnumUtil::EnumToString<VerificationType>(VerificationType value);

template <>
const char *EnumUtil::EnumToString<FileLockType>(FileLockType value);

template <>
const char *EnumUtil::EnumToString<FileBufferType>(FileBufferType value);

template <>
const char *EnumUtil::EnumToString<ExceptionFormatValueType>(ExceptionFormatValueType value);

template <>
const char *EnumUtil::EnumToString<ExtraTypeInfoType>(ExtraTypeInfoType value);

template <>
const char *EnumUtil::EnumToString<PhysicalType>(PhysicalType value);

template <>
const char *EnumUtil::EnumToString<LogicalTypeId>(LogicalTypeId value);

template <>
const char *EnumUtil::EnumToString<OutputStream>(OutputStream value);

template <>
const char *EnumUtil::EnumToString<TimestampCastResult>(TimestampCastResult value);

template <>
const char *EnumUtil::EnumToString<ConflictManagerMode>(ConflictManagerMode value);

template <>
const char *EnumUtil::EnumToString<LookupResultType>(LookupResultType value);

template <>
const char *EnumUtil::EnumToString<MapInvalidReason>(MapInvalidReason value);

template <>
const char *EnumUtil::EnumToString<UnionInvalidReason>(UnionInvalidReason value);

template <>
const char *EnumUtil::EnumToString<VectorBufferType>(VectorBufferType value);

template <>
const char *EnumUtil::EnumToString<VectorAuxiliaryDataType>(VectorAuxiliaryDataType value);

template <>
const char *EnumUtil::EnumToString<PartitionedColumnDataType>(PartitionedColumnDataType value);

template <>
const char *EnumUtil::EnumToString<ColumnDataAllocatorType>(ColumnDataAllocatorType value);

template <>
const char *EnumUtil::EnumToString<ColumnDataScanProperties>(ColumnDataScanProperties value);

template <>
const char *EnumUtil::EnumToString<PartitionedTupleDataType>(PartitionedTupleDataType value);

template <>
const char *EnumUtil::EnumToString<TupleDataPinProperties>(TupleDataPinProperties value);

template <>
const char *EnumUtil::EnumToString<PartitionSortStage>(PartitionSortStage value);

template <>
const char *EnumUtil::EnumToString<PhysicalOperatorType>(PhysicalOperatorType value);

template <>
const char *EnumUtil::EnumToString<VectorType>(VectorType value);

template <>
const char *EnumUtil::EnumToString<AccessMode>(AccessMode value);

template <>
const char *EnumUtil::EnumToString<FileGlobOptions>(FileGlobOptions value);

template <>
const char *EnumUtil::EnumToString<WALType>(WALType value);

template <>
const char *EnumUtil::EnumToString<JoinType>(JoinType value);

template <>
const char *EnumUtil::EnumToString<FileCompressionType>(FileCompressionType value);

template <>
const char *EnumUtil::EnumToString<ProfilerPrintFormat>(ProfilerPrintFormat value);

template <>
const char *EnumUtil::EnumToString<StatementType>(StatementType value);

template <>
const char *EnumUtil::EnumToString<StatementReturnType>(StatementReturnType value);

template <>
const char *EnumUtil::EnumToString<OrderPreservationType>(OrderPreservationType value);

template <>
const char *EnumUtil::EnumToString<DebugInitialize>(DebugInitialize value);

template <>
const char *EnumUtil::EnumToString<CatalogType>(CatalogType value);

template <>
const char *EnumUtil::EnumToString<SetScope>(SetScope value);

template <>
const char *EnumUtil::EnumToString<TableScanType>(TableScanType value);

template <>
const char *EnumUtil::EnumToString<SetType>(SetType value);

template <>
const char *EnumUtil::EnumToString<ExpressionType>(ExpressionType value);

template <>
const char *EnumUtil::EnumToString<ExpressionClass>(ExpressionClass value);

template <>
const char *EnumUtil::EnumToString<PendingExecutionResult>(PendingExecutionResult value);

template <>
const char *EnumUtil::EnumToString<WindowAggregationMode>(WindowAggregationMode value);

template <>
const char *EnumUtil::EnumToString<SubqueryType>(SubqueryType value);

template <>
const char *EnumUtil::EnumToString<OrderType>(OrderType value);

template <>
const char *EnumUtil::EnumToString<OrderByNullType>(OrderByNullType value);

template <>
const char *EnumUtil::EnumToString<DefaultOrderByNullType>(DefaultOrderByNullType value);

template <>
const char *EnumUtil::EnumToString<DatePartSpecifier>(DatePartSpecifier value);

template <>
const char *EnumUtil::EnumToString<OnEntryNotFound>(OnEntryNotFound value);

template <>
const char *EnumUtil::EnumToString<LogicalOperatorType>(LogicalOperatorType value);

template <>
const char *EnumUtil::EnumToString<OperatorResultType>(OperatorResultType value);

template <>
const char *EnumUtil::EnumToString<OperatorFinalizeResultType>(OperatorFinalizeResultType value);

template <>
const char *EnumUtil::EnumToString<SinkResultType>(SinkResultType value);

template <>
const char *EnumUtil::EnumToString<SinkFinalizeType>(SinkFinalizeType value);

template <>
const char *EnumUtil::EnumToString<JoinRefType>(JoinRefType value);

template <>
const char *EnumUtil::EnumToString<UndoFlags>(UndoFlags value);

template <>
const char *EnumUtil::EnumToString<SetOperationType>(SetOperationType value);

template <>
const char *EnumUtil::EnumToString<OptimizerType>(OptimizerType value);

template <>
const char *EnumUtil::EnumToString<CompressionType>(CompressionType value);

template <>
const char *EnumUtil::EnumToString<AggregateHandling>(AggregateHandling value);

template <>
const char *EnumUtil::EnumToString<TableReferenceType>(TableReferenceType value);

template <>
const char *EnumUtil::EnumToString<RelationType>(RelationType value);

template <>
const char *EnumUtil::EnumToString<FilterPropagateResult>(FilterPropagateResult value);

template <>
const char *EnumUtil::EnumToString<IndexType>(IndexType value);

template <>
const char *EnumUtil::EnumToString<ExplainOutputType>(ExplainOutputType value);

template <>
const char *EnumUtil::EnumToString<NType>(NType value);

template <>
const char *EnumUtil::EnumToString<VerifyExistenceType>(VerifyExistenceType value);

template <>
const char *EnumUtil::EnumToString<ParserMode>(ParserMode value);

template <>
const char *EnumUtil::EnumToString<ErrorType>(ErrorType value);

template <>
const char *EnumUtil::EnumToString<AppenderType>(AppenderType value);

template <>
const char *EnumUtil::EnumToString<CheckpointAbort>(CheckpointAbort value);

template <>
const char *EnumUtil::EnumToString<ExtensionLoadResult>(ExtensionLoadResult value);

template <>
const char *EnumUtil::EnumToString<QueryResultType>(QueryResultType value);

template <>
const char *EnumUtil::EnumToString<CAPIResultSetType>(CAPIResultSetType value);

template <>
TaskExecutionMode EnumUtil::StringToEnum<TaskExecutionMode>(const char *value);

template <>
TaskExecutionResult EnumUtil::StringToEnum<TaskExecutionResult>(const char *value);

template <>
DistinctType EnumUtil::StringToEnum<DistinctType>(const char *value);

template <>
TableFilterType EnumUtil::StringToEnum<TableFilterType>(const char *value);

template <>
BindingMode EnumUtil::StringToEnum<BindingMode>(const char *value);

template <>
TableColumnType EnumUtil::StringToEnum<TableColumnType>(const char *value);

template <>
AggregateType EnumUtil::StringToEnum<AggregateType>(const char *value);

template <>
AggregateOrderDependent EnumUtil::StringToEnum<AggregateOrderDependent>(const char *value);

template <>
FunctionNullHandling EnumUtil::StringToEnum<FunctionNullHandling>(const char *value);

template <>
FunctionSideEffects EnumUtil::StringToEnum<FunctionSideEffects>(const char *value);

template <>
MacroType EnumUtil::StringToEnum<MacroType>(const char *value);

template <>
ArrowVariableSizeType EnumUtil::StringToEnum<ArrowVariableSizeType>(const char *value);

template <>
ArrowDateTimeType EnumUtil::StringToEnum<ArrowDateTimeType>(const char *value);

template <>
StrTimeSpecifier EnumUtil::StringToEnum<StrTimeSpecifier>(const char *value);

template <>
SimplifiedTokenType EnumUtil::StringToEnum<SimplifiedTokenType>(const char *value);

template <>
KeywordCategory EnumUtil::StringToEnum<KeywordCategory>(const char *value);

template <>
ResultModifierType EnumUtil::StringToEnum<ResultModifierType>(const char *value);

template <>
ConstraintType EnumUtil::StringToEnum<ConstraintType>(const char *value);

template <>
ForeignKeyType EnumUtil::StringToEnum<ForeignKeyType>(const char *value);

template <>
ParserExtensionResultType EnumUtil::StringToEnum<ParserExtensionResultType>(const char *value);

template <>
QueryNodeType EnumUtil::StringToEnum<QueryNodeType>(const char *value);

template <>
SequenceInfo EnumUtil::StringToEnum<SequenceInfo>(const char *value);

template <>
AlterScalarFunctionType EnumUtil::StringToEnum<AlterScalarFunctionType>(const char *value);

template <>
AlterTableType EnumUtil::StringToEnum<AlterTableType>(const char *value);

template <>
AlterViewType EnumUtil::StringToEnum<AlterViewType>(const char *value);

template <>
AlterTableFunctionType EnumUtil::StringToEnum<AlterTableFunctionType>(const char *value);

template <>
AlterType EnumUtil::StringToEnum<AlterType>(const char *value);

template <>
PragmaType EnumUtil::StringToEnum<PragmaType>(const char *value);

template <>
OnCreateConflict EnumUtil::StringToEnum<OnCreateConflict>(const char *value);

template <>
TransactionType EnumUtil::StringToEnum<TransactionType>(const char *value);

template <>
SampleMethod EnumUtil::StringToEnum<SampleMethod>(const char *value);

template <>
ExplainType EnumUtil::StringToEnum<ExplainType>(const char *value);

template <>
OnConflictAction EnumUtil::StringToEnum<OnConflictAction>(const char *value);

template <>
WindowBoundary EnumUtil::StringToEnum<WindowBoundary>(const char *value);

template <>
DataFileType EnumUtil::StringToEnum<DataFileType>(const char *value);

template <>
StatsInfo EnumUtil::StringToEnum<StatsInfo>(const char *value);

template <>
StatisticsType EnumUtil::StringToEnum<StatisticsType>(const char *value);

template <>
ColumnSegmentType EnumUtil::StringToEnum<ColumnSegmentType>(const char *value);

template <>
ChunkInfoType EnumUtil::StringToEnum<ChunkInfoType>(const char *value);

template <>
BitpackingMode EnumUtil::StringToEnum<BitpackingMode>(const char *value);

template <>
BlockState EnumUtil::StringToEnum<BlockState>(const char *value);

template <>
VerificationType EnumUtil::StringToEnum<VerificationType>(const char *value);

template <>
FileLockType EnumUtil::StringToEnum<FileLockType>(const char *value);

template <>
FileBufferType EnumUtil::StringToEnum<FileBufferType>(const char *value);

template <>
ExceptionFormatValueType EnumUtil::StringToEnum<ExceptionFormatValueType>(const char *value);

template <>
ExtraTypeInfoType EnumUtil::StringToEnum<ExtraTypeInfoType>(const char *value);

template <>
PhysicalType EnumUtil::StringToEnum<PhysicalType>(const char *value);

template <>
LogicalTypeId EnumUtil::StringToEnum<LogicalTypeId>(const char *value);

template <>
OutputStream EnumUtil::StringToEnum<OutputStream>(const char *value);

template <>
TimestampCastResult EnumUtil::StringToEnum<TimestampCastResult>(const char *value);

template <>
ConflictManagerMode EnumUtil::StringToEnum<ConflictManagerMode>(const char *value);

template <>
LookupResultType EnumUtil::StringToEnum<LookupResultType>(const char *value);

template <>
MapInvalidReason EnumUtil::StringToEnum<MapInvalidReason>(const char *value);

template <>
UnionInvalidReason EnumUtil::StringToEnum<UnionInvalidReason>(const char *value);

template <>
VectorBufferType EnumUtil::StringToEnum<VectorBufferType>(const char *value);

template <>
VectorAuxiliaryDataType EnumUtil::StringToEnum<VectorAuxiliaryDataType>(const char *value);

template <>
PartitionedColumnDataType EnumUtil::StringToEnum<PartitionedColumnDataType>(const char *value);

template <>
ColumnDataAllocatorType EnumUtil::StringToEnum<ColumnDataAllocatorType>(const char *value);

template <>
ColumnDataScanProperties EnumUtil::StringToEnum<ColumnDataScanProperties>(const char *value);

template <>
PartitionedTupleDataType EnumUtil::StringToEnum<PartitionedTupleDataType>(const char *value);

template <>
TupleDataPinProperties EnumUtil::StringToEnum<TupleDataPinProperties>(const char *value);

template <>
PartitionSortStage EnumUtil::StringToEnum<PartitionSortStage>(const char *value);

template <>
PhysicalOperatorType EnumUtil::StringToEnum<PhysicalOperatorType>(const char *value);

template <>
VectorType EnumUtil::StringToEnum<VectorType>(const char *value);

template <>
AccessMode EnumUtil::StringToEnum<AccessMode>(const char *value);

template <>
FileGlobOptions EnumUtil::StringToEnum<FileGlobOptions>(const char *value);

template <>
WALType EnumUtil::StringToEnum<WALType>(const char *value);

template <>
JoinType EnumUtil::StringToEnum<JoinType>(const char *value);

template <>
FileCompressionType EnumUtil::StringToEnum<FileCompressionType>(const char *value);

template <>
ProfilerPrintFormat EnumUtil::StringToEnum<ProfilerPrintFormat>(const char *value);

template <>
StatementType EnumUtil::StringToEnum<StatementType>(const char *value);

template <>
StatementReturnType EnumUtil::StringToEnum<StatementReturnType>(const char *value);

template <>
OrderPreservationType EnumUtil::StringToEnum<OrderPreservationType>(const char *value);

template <>
DebugInitialize EnumUtil::StringToEnum<DebugInitialize>(const char *value);

template <>
CatalogType EnumUtil::StringToEnum<CatalogType>(const char *value);

template <>
SetScope EnumUtil::StringToEnum<SetScope>(const char *value);

template <>
TableScanType EnumUtil::StringToEnum<TableScanType>(const char *value);

template <>
SetType EnumUtil::StringToEnum<SetType>(const char *value);

template <>
ExpressionType EnumUtil::StringToEnum<ExpressionType>(const char *value);

template <>
ExpressionClass EnumUtil::StringToEnum<ExpressionClass>(const char *value);

template <>
PendingExecutionResult EnumUtil::StringToEnum<PendingExecutionResult>(const char *value);

template <>
WindowAggregationMode EnumUtil::StringToEnum<WindowAggregationMode>(const char *value);

template <>
SubqueryType EnumUtil::StringToEnum<SubqueryType>(const char *value);

template <>
OrderType EnumUtil::StringToEnum<OrderType>(const char *value);

template <>
OrderByNullType EnumUtil::StringToEnum<OrderByNullType>(const char *value);

template <>
DefaultOrderByNullType EnumUtil::StringToEnum<DefaultOrderByNullType>(const char *value);

template <>
DatePartSpecifier EnumUtil::StringToEnum<DatePartSpecifier>(const char *value);

template <>
OnEntryNotFound EnumUtil::StringToEnum<OnEntryNotFound>(const char *value);

template <>
LogicalOperatorType EnumUtil::StringToEnum<LogicalOperatorType>(const char *value);

template <>
OperatorResultType EnumUtil::StringToEnum<OperatorResultType>(const char *value);

template <>
OperatorFinalizeResultType EnumUtil::StringToEnum<OperatorFinalizeResultType>(const char *value);

template <>
SinkResultType EnumUtil::StringToEnum<SinkResultType>(const char *value);

template <>
SinkFinalizeType EnumUtil::StringToEnum<SinkFinalizeType>(const char *value);

template <>
JoinRefType EnumUtil::StringToEnum<JoinRefType>(const char *value);

template <>
UndoFlags EnumUtil::StringToEnum<UndoFlags>(const char *value);

template <>
SetOperationType EnumUtil::StringToEnum<SetOperationType>(const char *value);

template <>
OptimizerType EnumUtil::StringToEnum<OptimizerType>(const char *value);

template <>
CompressionType EnumUtil::StringToEnum<CompressionType>(const char *value);

template <>
AggregateHandling EnumUtil::StringToEnum<AggregateHandling>(const char *value);

template <>
TableReferenceType EnumUtil::StringToEnum<TableReferenceType>(const char *value);

template <>
RelationType EnumUtil::StringToEnum<RelationType>(const char *value);

template <>
FilterPropagateResult EnumUtil::StringToEnum<FilterPropagateResult>(const char *value);

template <>
IndexType EnumUtil::StringToEnum<IndexType>(const char *value);

template <>
ExplainOutputType EnumUtil::StringToEnum<ExplainOutputType>(const char *value);

template <>
NType EnumUtil::StringToEnum<NType>(const char *value);

template <>
VerifyExistenceType EnumUtil::StringToEnum<VerifyExistenceType>(const char *value);

template <>
ParserMode EnumUtil::StringToEnum<ParserMode>(const char *value);

template <>
ErrorType EnumUtil::StringToEnum<ErrorType>(const char *value);

template <>
AppenderType EnumUtil::StringToEnum<AppenderType>(const char *value);

template <>
CheckpointAbort EnumUtil::StringToEnum<CheckpointAbort>(const char *value);

template <>
ExtensionLoadResult EnumUtil::StringToEnum<ExtensionLoadResult>(const char *value);

template <>
QueryResultType EnumUtil::StringToEnum<QueryResultType>(const char *value);

template <>
CAPIResultSetType EnumUtil::StringToEnum<CAPIResultSetType>(const char *value);

} // namespace duckdb
