//-------------------------------------------------------------------------
// This file is automatically generated by scripts/generate_enum_util.py
// Do not edit this file manually, your changes will be overwritten
// If you want to exclude an enum from serialization, add it to the blacklist in the script
//
// Note: The generated code will only work properly if the enum is a top level item in the duckdb namespace
// If the enum is nested in a class, or in another namespace, the generated code will not compile.
// You should move the enum to the duckdb namespae, manually write a specialization or add it to the blacklist
//-------------------------------------------------------------------------


#pragma once

#include <stdint.h>

namespace duckdb {

struct EnumUtils {
    // String -> Enum
    template <class T>
    static T StringToEnum(const char *value) = delete;

    // Enum -> String
    template <class T>
    static const char *EnumToString(T value) = delete;
};

enum class TaskExecutionMode : uint8_t;

enum class TaskExecutionResult : uint8_t;

enum class DistinctType : uint8_t;

enum class TableFilterType : uint8_t;

enum class BindingMode : uint8_t;

enum class TableColumnType : uint8_t;

enum class AggregateType : uint8_t;

enum class AggregateOrderDependent : uint8_t;

enum class FunctionNullHandling : uint8_t;

enum class FunctionSideEffects : uint8_t;

enum class MacroType : uint8_t;

enum class ArrowVariableSizeType : uint8_t;

enum class ArrowDateTimeType : uint8_t;

enum class StrTimeSpecifier : uint8_t;

enum class MapInvalidReason : uint8_t;

enum class UnionInvalidReason : uint8_t;

enum class SimplifiedTokenType : uint8_t;

enum class KeywordCategory : uint8_t;

enum class ResultModifierType : uint8_t;

enum class ConstraintType : uint8_t;

enum class ForeignKeyType : uint8_t;

enum class ParserExtensionResultType : uint8_t;

enum class QueryNodeType : uint8_t;

enum class SequenceInfo : uint8_t;

enum class AlterScalarFunctionType : uint8_t;

enum class AlterTableType : uint8_t;

enum class AlterViewType : uint8_t;

enum class AlterTableFunctionType : uint8_t;

enum class AlterType : uint8_t;

enum class PragmaType : uint8_t;

enum class OnCreateConflict : uint8_t;

enum class TransactionType : uint8_t;

enum class SampleMethod : uint8_t;

enum class ExplainType : uint8_t;

enum class OnConflictAction : uint8_t;

enum class WindowBoundary : uint8_t;

enum class DataFileType : uint8_t;

enum class StatsInfo : uint8_t;

enum class StatisticsType : uint8_t;

enum class ColumnSegmentType : uint8_t;

enum class ChunkInfoType : uint8_t;

enum class BitpackingMode : uint8_t;

enum class BlockState : uint8_t;

enum class VerificationType : uint8_t;

enum class FileLockType : uint8_t;

enum class FileBufferType : uint8_t;

enum class ExceptionFormatValueType : uint8_t;

enum class ExtraTypeInfoType : uint8_t;

enum class PhysicalType : uint8_t;

enum class LogicalTypeId : uint8_t;

enum class OutputStream : uint8_t;

enum class TimestampCastResult : uint8_t;

enum class ConflictManagerMode : uint8_t;

enum class LookupResultType : uint8_t;

enum class VectorBufferType : uint8_t;

enum class VectorAuxiliaryDataType : uint8_t;

enum class PartitionedColumnDataType : uint8_t;

enum class ColumnDataAllocatorType : uint8_t;

enum class ColumnDataScanProperties : uint8_t;

enum class PartitionedTupleDataType : uint8_t;

enum class TupleDataPinProperties : uint8_t;

enum class PartitionSortStage : uint8_t;

enum class PhysicalOperatorType : uint8_t;

enum class VectorType : uint8_t;

enum class AccessMode : uint8_t;

enum class FileGlobOptions : uint8_t;

enum class WALType : uint8_t;

enum class JoinType : uint8_t;

enum class FileCompressionType : uint8_t;

enum class ProfilerPrintFormat : uint8_t;

enum class StatementType : uint8_t;

enum class StatementReturnType : uint8_t;

enum class OrderPreservationType : uint8_t;

enum class CatalogType : uint8_t;

enum class SetScope : uint8_t;

enum class TableScanType : uint8_t;

enum class SetType : uint8_t;

enum class ExpressionType : uint8_t;

enum class ExpressionClass : uint8_t;

enum class PendingExecutionResult : uint8_t;

enum class WindowAggregationMode : uint32_t;

enum class SubqueryType : uint8_t;

enum class OrderType : uint8_t;

enum class OrderByNullType : uint8_t;

enum class DatePartSpecifier : uint8_t;

enum class LogicalOperatorType : uint8_t;

enum class OperatorResultType : uint8_t;

enum class OperatorFinalizeResultType : uint8_t;

enum class SinkResultType : uint8_t;

enum class SinkFinalizeType : uint8_t;

enum class JoinRefType : uint8_t;

enum class UndoFlags : uint32_t;

enum class SetOperationType : uint8_t;

enum class OptimizerType : uint32_t;

enum class CompressionType : uint8_t;

enum class AggregateHandling : uint8_t;

enum class TableReferenceType : uint8_t;

enum class RelationType : uint8_t;

enum class FilterPropagateResult : uint8_t;

enum class IndexType : uint8_t;

enum class ExplainOutputType : uint8_t;

enum class NodeType : uint8_t;

enum class VerifyExistenceType : uint8_t;

enum class ParserMode : uint8_t;

enum class ErrorType : uint16_t;

enum class AppenderType : uint8_t;

enum class CheckpointAbort : uint8_t;

enum class ExtensionLoadResult : uint8_t;

enum class QueryResultType : uint8_t;

enum class CAPIResultSetType : uint8_t;


template<>
const char* EnumUtils::EnumToString<TaskExecutionMode>(TaskExecutionMode value);

template<>
const char* EnumUtils::EnumToString<TaskExecutionResult>(TaskExecutionResult value);

template<>
const char* EnumUtils::EnumToString<DistinctType>(DistinctType value);

template<>
const char* EnumUtils::EnumToString<TableFilterType>(TableFilterType value);

template<>
const char* EnumUtils::EnumToString<BindingMode>(BindingMode value);

template<>
const char* EnumUtils::EnumToString<TableColumnType>(TableColumnType value);

template<>
const char* EnumUtils::EnumToString<AggregateType>(AggregateType value);

template<>
const char* EnumUtils::EnumToString<AggregateOrderDependent>(AggregateOrderDependent value);

template<>
const char* EnumUtils::EnumToString<FunctionNullHandling>(FunctionNullHandling value);

template<>
const char* EnumUtils::EnumToString<FunctionSideEffects>(FunctionSideEffects value);

template<>
const char* EnumUtils::EnumToString<MacroType>(MacroType value);

template<>
const char* EnumUtils::EnumToString<ArrowVariableSizeType>(ArrowVariableSizeType value);

template<>
const char* EnumUtils::EnumToString<ArrowDateTimeType>(ArrowDateTimeType value);

template<>
const char* EnumUtils::EnumToString<StrTimeSpecifier>(StrTimeSpecifier value);

template<>
const char* EnumUtils::EnumToString<MapInvalidReason>(MapInvalidReason value);

template<>
const char* EnumUtils::EnumToString<UnionInvalidReason>(UnionInvalidReason value);

template<>
const char* EnumUtils::EnumToString<SimplifiedTokenType>(SimplifiedTokenType value);

template<>
const char* EnumUtils::EnumToString<KeywordCategory>(KeywordCategory value);

template<>
const char* EnumUtils::EnumToString<ResultModifierType>(ResultModifierType value);

template<>
const char* EnumUtils::EnumToString<ConstraintType>(ConstraintType value);

template<>
const char* EnumUtils::EnumToString<ForeignKeyType>(ForeignKeyType value);

template<>
const char* EnumUtils::EnumToString<ParserExtensionResultType>(ParserExtensionResultType value);

template<>
const char* EnumUtils::EnumToString<QueryNodeType>(QueryNodeType value);

template<>
const char* EnumUtils::EnumToString<SequenceInfo>(SequenceInfo value);

template<>
const char* EnumUtils::EnumToString<AlterScalarFunctionType>(AlterScalarFunctionType value);

template<>
const char* EnumUtils::EnumToString<AlterTableType>(AlterTableType value);

template<>
const char* EnumUtils::EnumToString<AlterViewType>(AlterViewType value);

template<>
const char* EnumUtils::EnumToString<AlterTableFunctionType>(AlterTableFunctionType value);

template<>
const char* EnumUtils::EnumToString<AlterType>(AlterType value);

template<>
const char* EnumUtils::EnumToString<PragmaType>(PragmaType value);

template<>
const char* EnumUtils::EnumToString<OnCreateConflict>(OnCreateConflict value);

template<>
const char* EnumUtils::EnumToString<TransactionType>(TransactionType value);

template<>
const char* EnumUtils::EnumToString<SampleMethod>(SampleMethod value);

template<>
const char* EnumUtils::EnumToString<ExplainType>(ExplainType value);

template<>
const char* EnumUtils::EnumToString<OnConflictAction>(OnConflictAction value);

template<>
const char* EnumUtils::EnumToString<WindowBoundary>(WindowBoundary value);

template<>
const char* EnumUtils::EnumToString<DataFileType>(DataFileType value);

template<>
const char* EnumUtils::EnumToString<StatsInfo>(StatsInfo value);

template<>
const char* EnumUtils::EnumToString<StatisticsType>(StatisticsType value);

template<>
const char* EnumUtils::EnumToString<ColumnSegmentType>(ColumnSegmentType value);

template<>
const char* EnumUtils::EnumToString<ChunkInfoType>(ChunkInfoType value);

template<>
const char* EnumUtils::EnumToString<BitpackingMode>(BitpackingMode value);

template<>
const char* EnumUtils::EnumToString<BlockState>(BlockState value);

template<>
const char* EnumUtils::EnumToString<VerificationType>(VerificationType value);

template<>
const char* EnumUtils::EnumToString<FileLockType>(FileLockType value);

template<>
const char* EnumUtils::EnumToString<FileBufferType>(FileBufferType value);

template<>
const char* EnumUtils::EnumToString<ExceptionFormatValueType>(ExceptionFormatValueType value);

template<>
const char* EnumUtils::EnumToString<ExtraTypeInfoType>(ExtraTypeInfoType value);

template<>
const char* EnumUtils::EnumToString<PhysicalType>(PhysicalType value);

template<>
const char* EnumUtils::EnumToString<LogicalTypeId>(LogicalTypeId value);

template<>
const char* EnumUtils::EnumToString<OutputStream>(OutputStream value);

template<>
const char* EnumUtils::EnumToString<TimestampCastResult>(TimestampCastResult value);

template<>
const char* EnumUtils::EnumToString<ConflictManagerMode>(ConflictManagerMode value);

template<>
const char* EnumUtils::EnumToString<LookupResultType>(LookupResultType value);

template<>
const char* EnumUtils::EnumToString<VectorBufferType>(VectorBufferType value);

template<>
const char* EnumUtils::EnumToString<VectorAuxiliaryDataType>(VectorAuxiliaryDataType value);

template<>
const char* EnumUtils::EnumToString<PartitionedColumnDataType>(PartitionedColumnDataType value);

template<>
const char* EnumUtils::EnumToString<ColumnDataAllocatorType>(ColumnDataAllocatorType value);

template<>
const char* EnumUtils::EnumToString<ColumnDataScanProperties>(ColumnDataScanProperties value);

template<>
const char* EnumUtils::EnumToString<PartitionedTupleDataType>(PartitionedTupleDataType value);

template<>
const char* EnumUtils::EnumToString<TupleDataPinProperties>(TupleDataPinProperties value);

template<>
const char* EnumUtils::EnumToString<PartitionSortStage>(PartitionSortStage value);

template<>
const char* EnumUtils::EnumToString<PhysicalOperatorType>(PhysicalOperatorType value);

template<>
const char* EnumUtils::EnumToString<VectorType>(VectorType value);

template<>
const char* EnumUtils::EnumToString<AccessMode>(AccessMode value);

template<>
const char* EnumUtils::EnumToString<FileGlobOptions>(FileGlobOptions value);

template<>
const char* EnumUtils::EnumToString<WALType>(WALType value);

template<>
const char* EnumUtils::EnumToString<JoinType>(JoinType value);

template<>
const char* EnumUtils::EnumToString<FileCompressionType>(FileCompressionType value);

template<>
const char* EnumUtils::EnumToString<ProfilerPrintFormat>(ProfilerPrintFormat value);

template<>
const char* EnumUtils::EnumToString<StatementType>(StatementType value);

template<>
const char* EnumUtils::EnumToString<StatementReturnType>(StatementReturnType value);

template<>
const char* EnumUtils::EnumToString<OrderPreservationType>(OrderPreservationType value);

template<>
const char* EnumUtils::EnumToString<CatalogType>(CatalogType value);

template<>
const char* EnumUtils::EnumToString<SetScope>(SetScope value);

template<>
const char* EnumUtils::EnumToString<TableScanType>(TableScanType value);

template<>
const char* EnumUtils::EnumToString<SetType>(SetType value);

template<>
const char* EnumUtils::EnumToString<ExpressionType>(ExpressionType value);

template<>
const char* EnumUtils::EnumToString<ExpressionClass>(ExpressionClass value);

template<>
const char* EnumUtils::EnumToString<PendingExecutionResult>(PendingExecutionResult value);

template<>
const char* EnumUtils::EnumToString<WindowAggregationMode>(WindowAggregationMode value);

template<>
const char* EnumUtils::EnumToString<SubqueryType>(SubqueryType value);

template<>
const char* EnumUtils::EnumToString<OrderType>(OrderType value);

template<>
const char* EnumUtils::EnumToString<OrderByNullType>(OrderByNullType value);

template<>
const char* EnumUtils::EnumToString<DatePartSpecifier>(DatePartSpecifier value);

template<>
const char* EnumUtils::EnumToString<LogicalOperatorType>(LogicalOperatorType value);

template<>
const char* EnumUtils::EnumToString<OperatorResultType>(OperatorResultType value);

template<>
const char* EnumUtils::EnumToString<OperatorFinalizeResultType>(OperatorFinalizeResultType value);

template<>
const char* EnumUtils::EnumToString<SinkResultType>(SinkResultType value);

template<>
const char* EnumUtils::EnumToString<SinkFinalizeType>(SinkFinalizeType value);

template<>
const char* EnumUtils::EnumToString<JoinRefType>(JoinRefType value);

template<>
const char* EnumUtils::EnumToString<UndoFlags>(UndoFlags value);

template<>
const char* EnumUtils::EnumToString<SetOperationType>(SetOperationType value);

template<>
const char* EnumUtils::EnumToString<OptimizerType>(OptimizerType value);

template<>
const char* EnumUtils::EnumToString<CompressionType>(CompressionType value);

template<>
const char* EnumUtils::EnumToString<AggregateHandling>(AggregateHandling value);

template<>
const char* EnumUtils::EnumToString<TableReferenceType>(TableReferenceType value);

template<>
const char* EnumUtils::EnumToString<RelationType>(RelationType value);

template<>
const char* EnumUtils::EnumToString<FilterPropagateResult>(FilterPropagateResult value);

template<>
const char* EnumUtils::EnumToString<IndexType>(IndexType value);

template<>
const char* EnumUtils::EnumToString<ExplainOutputType>(ExplainOutputType value);

template<>
const char* EnumUtils::EnumToString<NodeType>(NodeType value);

template<>
const char* EnumUtils::EnumToString<VerifyExistenceType>(VerifyExistenceType value);

template<>
const char* EnumUtils::EnumToString<ParserMode>(ParserMode value);

template<>
const char* EnumUtils::EnumToString<ErrorType>(ErrorType value);

template<>
const char* EnumUtils::EnumToString<AppenderType>(AppenderType value);

template<>
const char* EnumUtils::EnumToString<CheckpointAbort>(CheckpointAbort value);

template<>
const char* EnumUtils::EnumToString<ExtensionLoadResult>(ExtensionLoadResult value);

template<>
const char* EnumUtils::EnumToString<QueryResultType>(QueryResultType value);

template<>
const char* EnumUtils::EnumToString<CAPIResultSetType>(CAPIResultSetType value);


template<>
TaskExecutionMode EnumUtils::StringToEnum<TaskExecutionMode>(const char *value);

template<>
TaskExecutionResult EnumUtils::StringToEnum<TaskExecutionResult>(const char *value);

template<>
DistinctType EnumUtils::StringToEnum<DistinctType>(const char *value);

template<>
TableFilterType EnumUtils::StringToEnum<TableFilterType>(const char *value);

template<>
BindingMode EnumUtils::StringToEnum<BindingMode>(const char *value);

template<>
TableColumnType EnumUtils::StringToEnum<TableColumnType>(const char *value);

template<>
AggregateType EnumUtils::StringToEnum<AggregateType>(const char *value);

template<>
AggregateOrderDependent EnumUtils::StringToEnum<AggregateOrderDependent>(const char *value);

template<>
FunctionNullHandling EnumUtils::StringToEnum<FunctionNullHandling>(const char *value);

template<>
FunctionSideEffects EnumUtils::StringToEnum<FunctionSideEffects>(const char *value);

template<>
MacroType EnumUtils::StringToEnum<MacroType>(const char *value);

template<>
ArrowVariableSizeType EnumUtils::StringToEnum<ArrowVariableSizeType>(const char *value);

template<>
ArrowDateTimeType EnumUtils::StringToEnum<ArrowDateTimeType>(const char *value);

template<>
StrTimeSpecifier EnumUtils::StringToEnum<StrTimeSpecifier>(const char *value);

template<>
MapInvalidReason EnumUtils::StringToEnum<MapInvalidReason>(const char *value);

template<>
UnionInvalidReason EnumUtils::StringToEnum<UnionInvalidReason>(const char *value);

template<>
SimplifiedTokenType EnumUtils::StringToEnum<SimplifiedTokenType>(const char *value);

template<>
KeywordCategory EnumUtils::StringToEnum<KeywordCategory>(const char *value);

template<>
ResultModifierType EnumUtils::StringToEnum<ResultModifierType>(const char *value);

template<>
ConstraintType EnumUtils::StringToEnum<ConstraintType>(const char *value);

template<>
ForeignKeyType EnumUtils::StringToEnum<ForeignKeyType>(const char *value);

template<>
ParserExtensionResultType EnumUtils::StringToEnum<ParserExtensionResultType>(const char *value);

template<>
QueryNodeType EnumUtils::StringToEnum<QueryNodeType>(const char *value);

template<>
SequenceInfo EnumUtils::StringToEnum<SequenceInfo>(const char *value);

template<>
AlterScalarFunctionType EnumUtils::StringToEnum<AlterScalarFunctionType>(const char *value);

template<>
AlterTableType EnumUtils::StringToEnum<AlterTableType>(const char *value);

template<>
AlterViewType EnumUtils::StringToEnum<AlterViewType>(const char *value);

template<>
AlterTableFunctionType EnumUtils::StringToEnum<AlterTableFunctionType>(const char *value);

template<>
AlterType EnumUtils::StringToEnum<AlterType>(const char *value);

template<>
PragmaType EnumUtils::StringToEnum<PragmaType>(const char *value);

template<>
OnCreateConflict EnumUtils::StringToEnum<OnCreateConflict>(const char *value);

template<>
TransactionType EnumUtils::StringToEnum<TransactionType>(const char *value);

template<>
SampleMethod EnumUtils::StringToEnum<SampleMethod>(const char *value);

template<>
ExplainType EnumUtils::StringToEnum<ExplainType>(const char *value);

template<>
OnConflictAction EnumUtils::StringToEnum<OnConflictAction>(const char *value);

template<>
WindowBoundary EnumUtils::StringToEnum<WindowBoundary>(const char *value);

template<>
DataFileType EnumUtils::StringToEnum<DataFileType>(const char *value);

template<>
StatsInfo EnumUtils::StringToEnum<StatsInfo>(const char *value);

template<>
StatisticsType EnumUtils::StringToEnum<StatisticsType>(const char *value);

template<>
ColumnSegmentType EnumUtils::StringToEnum<ColumnSegmentType>(const char *value);

template<>
ChunkInfoType EnumUtils::StringToEnum<ChunkInfoType>(const char *value);

template<>
BitpackingMode EnumUtils::StringToEnum<BitpackingMode>(const char *value);

template<>
BlockState EnumUtils::StringToEnum<BlockState>(const char *value);

template<>
VerificationType EnumUtils::StringToEnum<VerificationType>(const char *value);

template<>
FileLockType EnumUtils::StringToEnum<FileLockType>(const char *value);

template<>
FileBufferType EnumUtils::StringToEnum<FileBufferType>(const char *value);

template<>
ExceptionFormatValueType EnumUtils::StringToEnum<ExceptionFormatValueType>(const char *value);

template<>
ExtraTypeInfoType EnumUtils::StringToEnum<ExtraTypeInfoType>(const char *value);

template<>
PhysicalType EnumUtils::StringToEnum<PhysicalType>(const char *value);

template<>
LogicalTypeId EnumUtils::StringToEnum<LogicalTypeId>(const char *value);

template<>
OutputStream EnumUtils::StringToEnum<OutputStream>(const char *value);

template<>
TimestampCastResult EnumUtils::StringToEnum<TimestampCastResult>(const char *value);

template<>
ConflictManagerMode EnumUtils::StringToEnum<ConflictManagerMode>(const char *value);

template<>
LookupResultType EnumUtils::StringToEnum<LookupResultType>(const char *value);

template<>
VectorBufferType EnumUtils::StringToEnum<VectorBufferType>(const char *value);

template<>
VectorAuxiliaryDataType EnumUtils::StringToEnum<VectorAuxiliaryDataType>(const char *value);

template<>
PartitionedColumnDataType EnumUtils::StringToEnum<PartitionedColumnDataType>(const char *value);

template<>
ColumnDataAllocatorType EnumUtils::StringToEnum<ColumnDataAllocatorType>(const char *value);

template<>
ColumnDataScanProperties EnumUtils::StringToEnum<ColumnDataScanProperties>(const char *value);

template<>
PartitionedTupleDataType EnumUtils::StringToEnum<PartitionedTupleDataType>(const char *value);

template<>
TupleDataPinProperties EnumUtils::StringToEnum<TupleDataPinProperties>(const char *value);

template<>
PartitionSortStage EnumUtils::StringToEnum<PartitionSortStage>(const char *value);

template<>
PhysicalOperatorType EnumUtils::StringToEnum<PhysicalOperatorType>(const char *value);

template<>
VectorType EnumUtils::StringToEnum<VectorType>(const char *value);

template<>
AccessMode EnumUtils::StringToEnum<AccessMode>(const char *value);

template<>
FileGlobOptions EnumUtils::StringToEnum<FileGlobOptions>(const char *value);

template<>
WALType EnumUtils::StringToEnum<WALType>(const char *value);

template<>
JoinType EnumUtils::StringToEnum<JoinType>(const char *value);

template<>
FileCompressionType EnumUtils::StringToEnum<FileCompressionType>(const char *value);

template<>
ProfilerPrintFormat EnumUtils::StringToEnum<ProfilerPrintFormat>(const char *value);

template<>
StatementType EnumUtils::StringToEnum<StatementType>(const char *value);

template<>
StatementReturnType EnumUtils::StringToEnum<StatementReturnType>(const char *value);

template<>
OrderPreservationType EnumUtils::StringToEnum<OrderPreservationType>(const char *value);

template<>
CatalogType EnumUtils::StringToEnum<CatalogType>(const char *value);

template<>
SetScope EnumUtils::StringToEnum<SetScope>(const char *value);

template<>
TableScanType EnumUtils::StringToEnum<TableScanType>(const char *value);

template<>
SetType EnumUtils::StringToEnum<SetType>(const char *value);

template<>
ExpressionType EnumUtils::StringToEnum<ExpressionType>(const char *value);

template<>
ExpressionClass EnumUtils::StringToEnum<ExpressionClass>(const char *value);

template<>
PendingExecutionResult EnumUtils::StringToEnum<PendingExecutionResult>(const char *value);

template<>
WindowAggregationMode EnumUtils::StringToEnum<WindowAggregationMode>(const char *value);

template<>
SubqueryType EnumUtils::StringToEnum<SubqueryType>(const char *value);

template<>
OrderType EnumUtils::StringToEnum<OrderType>(const char *value);

template<>
OrderByNullType EnumUtils::StringToEnum<OrderByNullType>(const char *value);

template<>
DatePartSpecifier EnumUtils::StringToEnum<DatePartSpecifier>(const char *value);

template<>
LogicalOperatorType EnumUtils::StringToEnum<LogicalOperatorType>(const char *value);

template<>
OperatorResultType EnumUtils::StringToEnum<OperatorResultType>(const char *value);

template<>
OperatorFinalizeResultType EnumUtils::StringToEnum<OperatorFinalizeResultType>(const char *value);

template<>
SinkResultType EnumUtils::StringToEnum<SinkResultType>(const char *value);

template<>
SinkFinalizeType EnumUtils::StringToEnum<SinkFinalizeType>(const char *value);

template<>
JoinRefType EnumUtils::StringToEnum<JoinRefType>(const char *value);

template<>
UndoFlags EnumUtils::StringToEnum<UndoFlags>(const char *value);

template<>
SetOperationType EnumUtils::StringToEnum<SetOperationType>(const char *value);

template<>
OptimizerType EnumUtils::StringToEnum<OptimizerType>(const char *value);

template<>
CompressionType EnumUtils::StringToEnum<CompressionType>(const char *value);

template<>
AggregateHandling EnumUtils::StringToEnum<AggregateHandling>(const char *value);

template<>
TableReferenceType EnumUtils::StringToEnum<TableReferenceType>(const char *value);

template<>
RelationType EnumUtils::StringToEnum<RelationType>(const char *value);

template<>
FilterPropagateResult EnumUtils::StringToEnum<FilterPropagateResult>(const char *value);

template<>
IndexType EnumUtils::StringToEnum<IndexType>(const char *value);

template<>
ExplainOutputType EnumUtils::StringToEnum<ExplainOutputType>(const char *value);

template<>
NodeType EnumUtils::StringToEnum<NodeType>(const char *value);

template<>
VerifyExistenceType EnumUtils::StringToEnum<VerifyExistenceType>(const char *value);

template<>
ParserMode EnumUtils::StringToEnum<ParserMode>(const char *value);

template<>
ErrorType EnumUtils::StringToEnum<ErrorType>(const char *value);

template<>
AppenderType EnumUtils::StringToEnum<AppenderType>(const char *value);

template<>
CheckpointAbort EnumUtils::StringToEnum<CheckpointAbort>(const char *value);

template<>
ExtensionLoadResult EnumUtils::StringToEnum<ExtensionLoadResult>(const char *value);

template<>
QueryResultType EnumUtils::StringToEnum<QueryResultType>(const char *value);

template<>
CAPIResultSetType EnumUtils::StringToEnum<CAPIResultSetType>(const char *value);


}
