//===----------------------------------------------------------------------===//
// This file is automatically generated by scripts/generate_serialization.py
// Do not edit this file manually, your changes will be overwritten
//===----------------------------------------------------------------------===//

#include "duckdb/common/serializer/format_serializer.hpp"
#include "duckdb/common/serializer/format_deserializer.hpp"
#include "duckdb/planner/expression/list.hpp"

namespace duckdb {

void Expression::FormatSerialize(FormatSerializer &serializer) const {
	serializer.WriteProperty("expression_class", expression_class);
	serializer.WriteProperty("type", type);
	serializer.WriteProperty("alias", alias);
}

unique_ptr<Expression> Expression::FormatDeserialize(FormatDeserializer &deserializer) {
	auto expression_class = deserializer.ReadProperty<ExpressionClass>("expression_class");
	auto type = deserializer.ReadProperty<ExpressionType>("type");
	auto alias = deserializer.ReadProperty<string>("alias");
	deserializer.Set<ExpressionType>(type);
	unique_ptr<Expression> result;
	switch (expression_class) {
	case ExpressionClass::BOUND_BETWEEN:
		result = BoundBetweenExpression::FormatDeserialize(deserializer);
		break;
	case ExpressionClass::BOUND_CASE:
		result = BoundCaseExpression::FormatDeserialize(deserializer);
		break;
	default:
		throw SerializationException("Unsupported type for deserialization of Expression!");
	}
	deserializer.Unset<ExpressionType>();
	result->alias = std::move(alias);
	return result;
}

void BoundBetweenExpression::FormatSerialize(FormatSerializer &serializer) const {
	Expression::FormatSerialize(serializer);
	serializer.WriteProperty("input", *input);
	serializer.WriteProperty("lower", *lower);
	serializer.WriteProperty("upper", *upper);
	serializer.WriteProperty("lower_inclusive", lower_inclusive);
	serializer.WriteProperty("upper_inclusive", upper_inclusive);
}

unique_ptr<Expression> BoundBetweenExpression::FormatDeserialize(FormatDeserializer &deserializer) {
	auto result = duckdb::unique_ptr<BoundBetweenExpression>(new BoundBetweenExpression());
	deserializer.ReadProperty("input", result->input);
	deserializer.ReadProperty("lower", result->lower);
	deserializer.ReadProperty("upper", result->upper);
	deserializer.ReadProperty("lower_inclusive", result->lower_inclusive);
	deserializer.ReadProperty("upper_inclusive", result->upper_inclusive);
	return std::move(result);
}

void BoundCaseExpression::FormatSerialize(FormatSerializer &serializer) const {
	Expression::FormatSerialize(serializer);
	serializer.WriteProperty("return_type", return_type);
	serializer.WriteProperty("case_checks", case_checks);
	serializer.WriteProperty("else_expr", *else_expr);
}

unique_ptr<Expression> BoundCaseExpression::FormatDeserialize(FormatDeserializer &deserializer) {
	auto return_type = deserializer.ReadProperty<LogicalType>("return_type");
	auto result = duckdb::unique_ptr<BoundCaseExpression>(new BoundCaseExpression(std::move(return_type)));
	deserializer.ReadProperty("case_checks", result->case_checks);
	deserializer.ReadProperty("else_expr", result->else_expr);
	return std::move(result);
}

} // namespace duckdb
