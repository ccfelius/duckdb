//===----------------------------------------------------------------------===//
// This file is automatically generated by scripts/generate_serialization.py
// Do not edit this file manually, your changes will be overwritten
//===----------------------------------------------------------------------===//

#include "duckdb/common/serializer/format_serializer.hpp"
#include "duckdb/common/serializer/format_deserializer.hpp"
#include "duckdb/planner/expression/list.hpp"

namespace duckdb {

void Expression::FormatSerialize(FormatSerializer &serializer) const {
	serializer.WriteProperty("expression_class", expression_class);
	serializer.WriteProperty("type", type);
	serializer.WriteProperty("alias", alias);
}

unique_ptr<Expression> Expression::FormatDeserialize(FormatDeserializer &deserializer) {
	auto expression_class = deserializer.ReadProperty<ExpressionClass>("expression_class");
	auto type = deserializer.ReadProperty<ExpressionType>("type");
	auto alias = deserializer.ReadProperty<string>("alias");
	deserializer.Set<ExpressionType>(type);
	unique_ptr<Expression> result;
	switch (expression_class) {
	case ExpressionClass::BOUND_BETWEEN:
		result = BoundBetweenExpression::FormatDeserialize(deserializer);
		break;
	case ExpressionClass::BOUND_CASE:
		result = BoundCaseExpression::FormatDeserialize(deserializer);
		break;
	case ExpressionClass::BOUND_CAST:
		result = BoundCastExpression::FormatDeserialize(deserializer);
		break;
	case ExpressionClass::BOUND_COLUMN_REF:
		result = BoundColumnRefExpression::FormatDeserialize(deserializer);
		break;
	default:
		throw SerializationException("Unsupported type for deserialization of Expression!");
	}
	deserializer.Unset<ExpressionType>();
	result->alias = std::move(alias);
	return result;
}

void BoundBetweenExpression::FormatSerialize(FormatSerializer &serializer) const {
	Expression::FormatSerialize(serializer);
	serializer.WriteProperty("input", *input);
	serializer.WriteProperty("lower", *lower);
	serializer.WriteProperty("upper", *upper);
	serializer.WriteProperty("lower_inclusive", lower_inclusive);
	serializer.WriteProperty("upper_inclusive", upper_inclusive);
}

unique_ptr<Expression> BoundBetweenExpression::FormatDeserialize(FormatDeserializer &deserializer) {
	auto result = duckdb::unique_ptr<BoundBetweenExpression>(new BoundBetweenExpression());
	deserializer.ReadProperty("input", result->input);
	deserializer.ReadProperty("lower", result->lower);
	deserializer.ReadProperty("upper", result->upper);
	deserializer.ReadProperty("lower_inclusive", result->lower_inclusive);
	deserializer.ReadProperty("upper_inclusive", result->upper_inclusive);
	return std::move(result);
}

void BoundCaseExpression::FormatSerialize(FormatSerializer &serializer) const {
	Expression::FormatSerialize(serializer);
	serializer.WriteProperty("return_type", return_type);
	serializer.WriteProperty("case_checks", case_checks);
	serializer.WriteProperty("else_expr", *else_expr);
}

unique_ptr<Expression> BoundCaseExpression::FormatDeserialize(FormatDeserializer &deserializer) {
	auto return_type = deserializer.ReadProperty<LogicalType>("return_type");
	auto result = duckdb::unique_ptr<BoundCaseExpression>(new BoundCaseExpression(std::move(return_type)));
	deserializer.ReadProperty("case_checks", result->case_checks);
	deserializer.ReadProperty("else_expr", result->else_expr);
	return std::move(result);
}

void BoundCastExpression::FormatSerialize(FormatSerializer &serializer) const {
	Expression::FormatSerialize(serializer);
	serializer.WriteProperty("child", *child);
	serializer.WriteProperty("return_type", return_type);
	serializer.WriteProperty("try_cast", try_cast);
}

unique_ptr<Expression> BoundCastExpression::FormatDeserialize(FormatDeserializer &deserializer) {
	auto child = deserializer.ReadProperty<unique_ptr<Expression>>("child");
	auto return_type = deserializer.ReadProperty<LogicalType>("return_type");
	auto result = duckdb::unique_ptr<BoundCastExpression>(new BoundCastExpression(deserializer.Get<ClientContext &>(), std::move(child), std::move(return_type)));
	deserializer.ReadProperty("try_cast", result->try_cast);
	return std::move(result);
}

void BoundColumnRefExpression::FormatSerialize(FormatSerializer &serializer) const {
	Expression::FormatSerialize(serializer);
	serializer.WriteProperty("return_type", return_type);
	serializer.WriteProperty("binding", binding);
	serializer.WriteProperty("depth", depth);
}

unique_ptr<Expression> BoundColumnRefExpression::FormatDeserialize(FormatDeserializer &deserializer) {
	auto return_type = deserializer.ReadProperty<LogicalType>("return_type");
	auto binding = deserializer.ReadProperty<ColumnBinding>("binding");
	auto depth = deserializer.ReadProperty<idx_t>("depth");
	auto result = duckdb::unique_ptr<BoundColumnRefExpression>(new BoundColumnRefExpression(std::move(return_type), binding, depth));
	return std::move(result);
}

} // namespace duckdb
