//===----------------------------------------------------------------------===//
// This file is automatically generated by scripts/generate_serialization.py
// Do not edit this file manually, your changes will be overwritten
//===----------------------------------------------------------------------===//

#include "duckdb/common/serializer/format_serializer.hpp"
#include "duckdb/common/serializer/format_deserializer.hpp"
#include "duckdb/planner/operator/list.hpp"

namespace duckdb {

void LogicalOperator::FormatSerialize(FormatSerializer &serializer) const {
	serializer.WriteProperty("type", type);
	serializer.WriteProperty("children", children);
}

unique_ptr<LogicalOperator> LogicalOperator::FormatDeserialize(FormatDeserializer &deserializer) {
	auto type = deserializer.ReadProperty<LogicalOperatorType>("type");
	auto children = deserializer.ReadProperty<vector<unique_ptr<LogicalOperator>>>("children");
	unique_ptr<LogicalOperator> result;
	switch (type) {
	case LogicalOperatorType::LOGICAL_AGGREGATE_AND_GROUP_BY:
		result = LogicalAggregate::FormatDeserialize(deserializer);
		break;
	case LogicalOperatorType::LOGICAL_FILTER:
		result = LogicalFilter::FormatDeserialize(deserializer);
		break;
	case LogicalOperatorType::LOGICAL_PROJECTION:
		result = LogicalProjection::FormatDeserialize(deserializer);
		break;
	default:
		throw SerializationException("Unsupported type for deserialization of LogicalOperator!");
	}
	result->children = std::move(children);
	return result;
}

void LogicalAggregate::FormatSerialize(FormatSerializer &serializer) const {
	LogicalOperator::FormatSerialize(serializer);
	serializer.WriteProperty("expressions", expressions);
	serializer.WriteProperty("group_index", group_index);
	serializer.WriteProperty("aggregate_index", aggregate_index);
	serializer.WriteProperty("groupings_index", groupings_index);
	serializer.WriteProperty("groups", groups);
	serializer.WriteProperty("grouping_sets", grouping_sets);
	serializer.WriteProperty("grouping_functions", grouping_functions);
}

unique_ptr<LogicalOperator> LogicalAggregate::FormatDeserialize(FormatDeserializer &deserializer) {
	auto group_index = deserializer.ReadProperty<idx_t>("group_index");
	auto aggregate_index = deserializer.ReadProperty<idx_t>("aggregate_index");
	auto expressions = deserializer.ReadProperty<vector<unique_ptr<Expression>>>("expressions");
	auto result = duckdb::unique_ptr<LogicalAggregate>(new LogicalAggregate(group_index, aggregate_index, std::move(expressions)));
	deserializer.ReadProperty("groupings_index", result->groupings_index);
	deserializer.ReadProperty("groups", result->groups);
	deserializer.ReadProperty("grouping_sets", result->grouping_sets);
	deserializer.ReadProperty("grouping_functions", result->grouping_functions);
	return std::move(result);
}

void LogicalFilter::FormatSerialize(FormatSerializer &serializer) const {
	LogicalOperator::FormatSerialize(serializer);
	serializer.WriteProperty("expressions", expressions);
	serializer.WriteProperty("projection_map", projection_map);
}

unique_ptr<LogicalOperator> LogicalFilter::FormatDeserialize(FormatDeserializer &deserializer) {
	auto result = duckdb::unique_ptr<LogicalFilter>(new LogicalFilter());
	deserializer.ReadProperty("expressions", result->expressions);
	deserializer.ReadProperty("projection_map", result->projection_map);
	return std::move(result);
}

void LogicalProjection::FormatSerialize(FormatSerializer &serializer) const {
	LogicalOperator::FormatSerialize(serializer);
	serializer.WriteProperty("table_index", table_index);
	serializer.WriteProperty("expressions", expressions);
}

unique_ptr<LogicalOperator> LogicalProjection::FormatDeserialize(FormatDeserializer &deserializer) {
	auto table_index = deserializer.ReadProperty<idx_t>("table_index");
	auto expressions = deserializer.ReadProperty<vector<unique_ptr<Expression>>>("expressions");
	auto result = duckdb::unique_ptr<LogicalProjection>(new LogicalProjection(table_index, std::move(expressions)));
	return std::move(result);
}

} // namespace duckdb
