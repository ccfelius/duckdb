import os

# import re
import json

header = '''#ifndef DUCKDB_CONNECT_H
#define DUCKDB_CONNECT_H

//===----------------------------------------------------------------------===//
// This file is automatically generated by scripts/generate_connection_string_attributes.py
// Do not edit this file manually, your changes will be overwritten
//===----------------------------------------------------------------------===//

#include "duckdb_odbc.hpp"
#include "handle_functions.hpp"

#include <locale>
#include <odbcinst.h>

#define ROW_DEL ';'
#define KEY_VAL_DEL '='

namespace duckdb {

class Connect {
public:
'''

existing_functions = '''public:
\tConnect(OdbcHandleDbc *dbc_p, const std::string &input_str_p) : dbc(dbc_p), input_str(input_str_p) {};
\t~Connect() {};

\t// Checks if the key is set
\tbool CheckSet(ODBCConnStrKey key) { return set_keys.at(key); }
\t// Sets the variable for the key
\tSQLRETURN SetVal(ODBCConnStrKey key, const std::string &val);
\t// Checks if success with info has been returned and sets the variable
\tbool SetSuccessWithInfo(SQLRETURN ret);
\tSQLRETURN ParseInputStr();
\t// Splits the row into a key and value, and using SetVal sets the variable for the key
\tSQLRETURN FindKeyValPair(const std::string &row);
\t// Find the key that matches the keyname
\tSQLRETURN FindMatchingKey(const std::string &input, ODBCConnStrKey &key);
\t// If the input doesn't match a keyname, find a similar keyname
\tbool FindSimilar(const std::string &input, std::string &match);
\tSQLRETURN ReadFromIniFile();
\t// Executes the connection
\tSQLRETURN SetConnection();

'''

getters_str = '''// getters
\tstd::string GetInputStr() { return input_str; }
\tbool GetSuccessWithInfo() { return success_with_info; }
'''

footer = '''
private:
\tOdbcHandleDbc *dbc;
\tstd::string input_str;
\tbool success_with_info = false;
\tduckdb::DBConfig config;
};

} // namespace duckdb
#endif // DUCKDB_CONNECT_H
'''


# removes underscores and capitalizes first letter of each word
def rem_underscore_capitalize(s):
    return ''.join(x.capitalize() or '_' for x in s.split('_'))


enum_list = []
conn_str_map = {}
defaults = []

print(os.getcwd())

header_path = 'tools/odbc/include/connect.hpp'
json_path = 'tools/odbc/connection_string_attributes.json'
with open(json_path, 'r') as f:
    parsed_json = json.load(f)
for entry in parsed_json:
    enum_list.append(entry['enum'])
    conn_str_map[entry['enum']] = entry['keyword']
    defaults.append(entry['default'])

enum_str = '\tenum ODBCConnStrKey {\n'
for enum in enum_list:
    enum_str += '\t\t' + enum + ',\n'

enum_str += '\t};\n\n'

set_map_str = '\tstd::map<ODBCConnStrKey, bool> set_keys = {\n'
for enum in enum_list:
    set_map_str += '\t\t{' + enum + ', false},\n'

set_map_str += '\t};\n\n'

conn_str_map_str = '\tconst std::map<ODBCConnStrKey, std::string> conn_str_keynames = {\n'
handle_functions_map_str = (
    '\tusing f = SQLRETURN (Connect::*)(const std::string &);\n'
    '\tconst std::map<ODBCConnStrKey, f> handle_functions = {\n'
)
handle_val_str = '\n// handle values\n'
i = 0
for pair in conn_str_map.items():
    conn_str_map_str += '\t\t{' + pair[0] + ', "' + pair[1] + '"},\n'

    func_name = rem_underscore_capitalize(pair[1])

    handle_val_str += '\t SQLRETURN Handle' + func_name + '(const std::string &val);\n'

    handle_functions_map_str += '\t\t{' + pair[0] + ', &Connect::Handle' + func_name + '},\n'

    i += 1

conn_str_map_str += '\t};\n\n'
handle_functions_map_str += '\t};\n\n'

with open(header_path, 'w') as f:
    f.write(header)
    f.write(enum_str)
    f.write(conn_str_map_str)
    f.write(set_map_str)
    f.write(handle_functions_map_str)
    f.write(existing_functions)
    f.write(getters_str)
    f.write(handle_val_str)
    f.write(footer)
