[
	{
		"name": "cursor",
		"function": "Cursor",
		"docs": "Create a duplicate of the current connection",
		"return": "DuckDBPyConnection"
	},
	{
		"name": "register_filesystem",
		"function": "RegisterFilesystem",
		"docs": "Register a fsspec compliant filesystem",
		"args": [
			{
				"name": "filesystem",
				"type": "str"
			}
		]
	},
	{
		"name": "unregister_filesystem",
		"function": "UnregisterFilesystem",
		"docs": "Unregister a filesystem",
		"args": [
			{
				"name": "name",
				"type": "str"
			}
		]
	},
	{
		"name": "list_filesystems",
		"function": "ListFilesystems",
		"docs": "List registered filesystems, including builtin ones",
		"return": "list"
	},
	{
		"name": "filesystem_is_registered",
		"function": "FileSystemIsRegistered",
		"docs": "Check if a filesystem with the provided name is currently registered",
		"args": [
			{
				"name": "name"
			}
		],
		"return": "bool"
	},
	{
		"name": "create_function",
		"function": "RegisterScalarUDF",
		"docs": "Create a DuckDB function out of the passing in Python function so it can be used in queries",
		"args": [
			{
				"name": "name",
				"type": "str"
			},
			{
				"name": "function",
				"type": "function"
			},
			{
				"name": "parameters",
				"type": "Optional[List[DuckDBPyType]]",
				"default": "None"
			},
			{
				"name": "return_type",
				"type": "Optional[DuckDBPyType]",
				"default": "None"
			}
		],
		"kwargs": [
			{
				"name": "type",
				"type": "Optional[PythonUDFType]",
				"default": "PythonUDFType.NATIVE"
			},
			{
				"name": "null_handling",
				"type": "Optional[FunctionNullHandling]",
				"default": "FunctionNullHandling.DEFAULT"
			},
			{
				"name": "exception_handling",
				"type": "Optional[PythonExceptionHandling]",
				"default": "PythonExceptionHandling.DEFAULT"
			},
			{
				"name": "side_effects",
				"type": "bool",
				"default": "False"
			}
		],
		"return": "DuckDBPyConnection"
	},
	{
		"name": "remove_function",
		"function": "UnregisterUDF",
		"docs": "Remove a previously created function",
		"args": [
			{
				"name": "name",
				"type": "str"
			}
		],
		"return": "DuckDBPyConnection"
	},

	{
		"name": ["sqltype", "dtype", "type"],
		"function": "Type",
		"docs": "Create a type object by parsing the 'type_str' string",
		"args": [
			{
				"name": "type_str"
			}
		],
		"return": 
	},
	{
		"name": "array_type",
		"function": "ArrayType",
		"docs": "Create an array type object of 'type'",
		"args": [

		]
		{
			"name": "type"
			.none(false)
		},
		{
			"name": "size"
			.none(false
		},
	},
	{
		"name": "list_type",
		"function": "ListType",
		"docs": "Create a list type object of 'type'",
		"args": [

		]
		{
			"name": "type"
			.none(false
		},
	},
	{
		"name": "union_type",
		"function": "UnionType",
		"docs": "Create a union type object from 'members'",
		"args": [

		]
		{
			"name": "members"
			.none(false)
		},
	},
	{
		"name": "string_type",
		"function": "StringType",
		"docs": "Create a string type with an optional collation",
		"args": [

		]
		{
			"name": "collation"
			 = string()
		},
	},
	{
		"name": "enum_type",
		"function": "EnumType",
		"docs": "Create an enum type of underlying 'type', consisting of the list of 'values'",
		"args": [

		]
		{
			"name": "name"
		},
		{
			"name": "type"
		},
		{
			"name": "values"
		},
	},
	{
		"name": "decimal_type",
		"function": "DecimalType",
		"docs": "Create a decimal type with 'width' and 'scale'",
		"args": [

		]
		{
			"name": "width"
		},
		{
			"name": "scale"
		},
	},
	{
		"name": ["struct_type", "row_type"],
		"function": "StructType",
		"docs": "Create a struct type object from 'fields'",
			{
				"name": "fields"
			},
		},
	{
		"name": "map_type",
		"function": "MapType",
		"docs": "Create a map type object from 'key_type' and 'value_type'",
		"args": [

		]
		{
			"name": "key"
			.none(false)
		},
		{
			"name": "value"
			.none(false)
		},
	},
	{
		"name": "duplicate",
		"function": "Cursor",
		"docs": "Create a duplicate of the current connection",
	},
	{
		"name": "execute",
		"function": "Execute",
		"docs": "Execute the given SQL query, optionally using prepared statements with parameters set",
		"args": [

		]
		{
			"name": "query"
		},
		{
			"name": "parameters"
			 = py::none()
		},
		{
			"name": "multiple_parameter_sets"
			 = false
		},
	},
	{
		"name": "executemany",
		"function": "ExecuteMany",
		"docs": "Execute the given prepared statement multiple times using the list of parameter sets in parameters",
		"args": [

		]
		{
			"name": "query"
		},
		{
			"name": "parameters"
			 = py::none()
		},
	},
	{
		"name": "close",
		"function": "Close",
		"docs": "Close the connection"
	},
	{
		"name": "interrupt",
		"function": "Interrupt",
		"docs": "Interrupt pending operations"
	},
	{
		"name": "fetchone",
		"function": "FetchOne",
		"docs": "Fetch a single row from a result following execute"
	},
	{
		"name": "fetchmany",
		"function": "FetchMany",
		"docs": "Fetch the next set of rows from a result following execute"
		{
			"name": "size"
			 = 1
		},
	},
	{
		"name": "fetchall",
		"function": "FetchAll",
		"docs": "Fetch all rows from a result following execute"
	},
	{
		"name": "fetchnumpy",
		"function": "FetchNumpy",
		"docs": "Fetch a result as list of NumPy arrays following execute"
	},
	{
		"name": "fetchdf",
		"function": "FetchDF",
		"docs": "Fetch a result as DataFrame following execute()",
		py::kw_only(),
		{
			"name": "date_as_object"
			 = false
		},
	},
	{
		"name": "fetch_df",
		"function": "FetchDF",
		"docs": "Fetch a result as DataFrame following execute()",
		py::kw_only(),
		{
			"name": "date_as_object"
			 = false
		},
	},
	{
		"name": "fetch_df_chunk",
		"function": "FetchDFChunk",
		"docs": "Fetch a chunk of the result as Data.Frame following execute()",
		"args": [

		]
		{
			"name": "vectors_per_chunk"
			 = 1
		},
		py::kw_only(),
		{
			"name": "date_as_object"
			 = false
		},
	},
	{
		"name": "df",
		"function": "FetchDF",
		"docs": "Fetch a result as DataFrame following execute()",
		py::kw_only(),
		{
			"name": "date_as_object"
			 = false
		},
	},
	{
		"name": "pl",
		"function": "FetchPolars",
		"docs": "Fetch a result as Polars DataFrame following execute()",
		"args": [

		]
		{
			"name": "rows_per_batch"
			 = 1000000
		},
	},
	{
		"name": "fetch_arrow_table",
		"function": "FetchArrow",
		"docs": "Fetch a result as Arrow table following execute()",
		"args": [

		]
		{
			"name": "rows_per_batch"
			 = 1000000
		},
	},
	{
		"name": "fetch_record_batch",
		"function": "FetchRecordBatchReader",
		"docs": "Fetch an Arrow RecordBatchReader following execute()",
		"args": [

		]
		{
			"name": "rows_per_batch"
			 = 1000000
		},
	},
	{
		"name": "arrow",
		"function": "FetchArrow",
		"docs": "Fetch a result as Arrow table following execute()",
		"args": [

		]
		{
			"name": "rows_per_batch"
			 = 1000000
		},
	},
	{
		"name": "torch",
		"function": "FetchPyTorch",
		"docs": "Fetch a result as dict of PyTorch Tensors following execute()"

	},
	{
		"name": "tf",
		"function": "FetchTF",
		"docs": "Fetch a result as dict of TensorFlow Tensors following execute()"

	},
	{
		"name": "begin",
		"function": "Begin",
		"docs": "Start a new transaction"

	},
	{
		"name": "commit",
		"function": "Commit",
		"docs": "Commit changes performed within a transaction"
	},
	{
		"name": "rollback",
		"function": "Rollback",
		"docs": "Roll back changes performed within a transaction"
	},
	{
		"name": "append",
		"function": "Append",
		"docs": "Append the passed DataFrame to the named table",
		"args": [

		]
		{
			"name": "table_name"
		},
		{
			"name": "df"
		},
		py::kw_only(),
		{
			"name": "by_name"
			 = false
		},
	},
	{
		"name": "register",
		"function": "RegisterPythonObject",
		"docs": "Register the passed Python Object value for querying with a view",
		"args": [

		]
		{
			"name": "view_name"
		},
		{
			"name": "python_object"
		},
	},
	{
		"name": "unregister",
		"function": "UnregisterPythonObject",
		"docs": "Unregister the view name",
		"args": [

		]
		{
			"name": "view_name"
		},
	},
	{
		"name": "table",
		"function": "Table",
		"docs": "Create a relation object for the name'd table",
		"args": [

		]
		{
			"name": "table_name"
		},
	},
	{
		"name": "view",
		"function": "View",
		"docs": "Create a relation object for the name'd view",
		"args": [

		]
		{
			"name": "view_name"
		},
	},
	{
		"name": "values",
		"function": "Values",
		"docs": "Create a relation object from the passed values",
		"args": [

		]
		{
			"name": "values"
		},
	},
	{
		"name": "table_function",
		"function": "TableFunction",
		"docs": "Create a relation object from the name'd table function with given parameters",
		"args": [

		]
		{
			"name": "name"
		},
		{
			"name": "parameters"
			 = py::none()
		},
	},
	{
		"name": "read_json",
		"function": "ReadJSON",
		"docs": "Create a relation object from the JSON file in 'name'",
		"args": [

		]
		{
			"name": "name"
		},
		py::kw_only(),
		{
			"name": "columns"
			 = py::none()
		},
		{
			"name": "sample_size"
			 = py::none()
		},
		{
			"name": "maximum_depth"
			 = py::none()
		},
		{
			"name": "records"
			 = py::none()
		},
		{
			"name": "format"
			 = py::none()
		},
	},
	{
		"name": "extract_statements",
		"function": "ExtractStatements",
		"docs": "Parse the query string and extract the Statement object(s) produced",
		"args": [

		]
		{
			"name": "query"
		},
	},

	{
		"name": ["sql", "query", "from_query"],
		"function": "RunQuery",
		"docs": "Run a SQL query. If it is a SELECT statement, create a relation object from the given SQL query, otherwise run the query as-is.",
		"args": [

		]
		{
			"name": "query"
		},
		py::kw_only(),
		{
			"name": "alias"
			 = ""
		},
		{
			"name": "params"
			 = py::none(
		},
	},

	{
		"name": ["read_csv", "from_csv_auto"],
		"function": "ReadCSV",
		"docs": "Create a relation object from the CSV file in 'name'",
		"args": [

		]
		{
			"name": "name"
		},
		py::kw_only(),
		{
			"name": "header"
			 = py::none()
		},
		{
			"name": "compression"
			 = py::none()
		},
		{
			"name": "sep"
			 = py::none()
		},
		{
			"name": "delimiter"
			 = py::none()
		},
		{
			"name": "dtype"
			 = py::none()
		},
		{
			"name": "na_values"
			 = py::none()
		},
		{
			"name": "skiprows"
			 = py::none()
		},
		{
			"name": "quotechar"
			 = py::none()
		},
		{
			"name": "escapechar"
			 = py::none()
		},
		{
			"name": "encoding"
			 = py::none()
		},
		{
			"name": "parallel"
			 = py::none()
		},
		{
			"name": "date_format"
			 = py::none()
		},
		{
			"name": "timestamp_format"
			 = py::none()
		},
		{
			"name": "sample_size"
			 = py::none()
		},
		{
			"name": "all_varchar"
			 = py::none()
		},
		{
			"name": "normalize_names"
			 = py::none()
		},
		{
			"name": "filename"
			 = py::none()
		},
		{
			"name": "null_padding"
			 = py::none()
		},
		{
			"name": "names"
			 = py::none(
		},
	},
	{
		"name": "from_df",
		"function": "FromDF",
		"docs": "Create a relation object from the Data.Frame in df",
		"args": [

		]
		{
			"name": "df"
			 = py::none()
		},
	},
	{
		"name": "from_arrow",
		"function": "FromArrow",
		"docs": "Create a relation object from an Arrow object",
		"args": [

		]
		{
			"name": "arrow_object"
		},
	},

	{
		"name": ["from_parquet", "read_parquet"],
		"function": "FromParquet",
		"docs": "Create a relation object from the Parquet files in file_glob",
		"args": [

		]
		{
			"name": "file_glob"
		},
		{
			"name": "binary_as_string"
			 = false
		},
		py::kw_only(),
		{
			"name": "file_row_number"
			 = false
		},
		{
			"name": "filename"
			 = false
		},
		{
			"name": "hive_partitioning"
			 = false
		},
		{
			"name": "union_by_name"
			 = false
		},
		{
			"name": "compression"
			 = py::none(
		},
	},
	{
		"name": ["from_parquet", "read_parquet"],
		"function": "FromParquets",
		"docs": "Create a relation object from the Parquet files in file_globs",
		"args": [

		]
		{
			"name": "file_globs"
		},
		{
			"name": "binary_as_string"
			 = false
		},
		py::kw_only(),
		{
			"name": "file_row_number"
			 = false
		},
		{
			"name": "filename"
			 = false
		},
		{
			"name": "hive_partitioning"
			 = false
		},
		{
			"name": "union_by_name"
			 = false
		},
		{
			"name": "compression"
			 = py::none(
		},
	},
	{
		"name": "from_substrait",
		"function": "FromSubstrait",
		"docs": "Create a query object from protobuf plan",
		"args": [

		]
		{
			"name": "proto"
		},
	},
	{
		"name": "get_substrait",
		"function": "GetSubstrait",
		"docs": "Serialize a query to protobuf",
		"args": [

		]
		{
			"name": "query"
		},
		py::kw_only(),
		{
			"name": "enable_optimizer"
			 = true
		},
	},
	{
		"name": "get_substrait_json",
		"function": "GetSubstraitJSON",
		"docs": "Serialize a query to protobuf on the JSON format",
		"args": [

		]
		{
			"name": "query"
		},
		py::kw_only(),
		{
			"name": "enable_optimizer"
			 = true
		},
	},
	{
		"name": "from_substrait_json",
		"function": "FromSubstraitJSON",
		"docs": "Create a query object from a JSON protobuf plan",
		"args": [

		]
		{
			"name": "json"
		},
	},
	{
		"name": "get_table_names",
		"function": "GetTableNames",
		"docs": "Extract the required table names from a query",
		"args": [

		]
		{
			"name": "query"
		},
	},

	{
		"name": "install_extension",
		"function": "InstallExtension",
		"docs": "Install an extension by name",
		"args": [

		]
		{
			"name": "extension"
		},
		py::kw_only(),
		{
			"name": "force_install"
			 = false
		},
	},
	{
		"name": "load_extension",
		"function": "LoadExtension",
		"docs": "Load an installed extension",
		"args": [

		]
		{
			"name": "extension"
		},
	}
]
