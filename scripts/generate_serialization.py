import os
import json

source_path = os.path.sep.join('src/include/duckdb/storage/serialization/parsed_expression.json'.split('/'))
target_path = os.path.sep.join('src/storage/serialization/serialize_parsed_expression.cpp'.split('/'))

with open(source_path, 'r') as f:
    json_data = json.load(f)

base_class_name = None
base_class_data = {}
serialize_data = {}
include_list = ['duckdb/common/serializer/format_serializer.hpp', 'duckdb/common/serializer/format_deserializer.hpp']
extra_parameters = []
class_name_list = []

for entry in json_data:
    class_name = entry['class']
    if 'class_type' in entry:
        # base class
        base_class_name = class_name
        base_class_data[class_name] = {
            "__enum_value": entry['class_type']
        }
        include_list += entry['includes']
        if 'extra_parameters' in entry:
            extra_parameters = entry['extra_parameters']
    elif 'base' in entry:
        base_class = entry['base']
        enum_entry = entry['enum']
        if base_class not in base_class_data:
            raise Exception(f"Base class \"{base_class}\" not found")
        base_class_data[base_class][enum_entry] = class_name
    class_name_list.append(class_name)
    serialize_data[class_name] = entry['members']

include_base = '''#include "${FILENAME}"
'''

header = '''// GENERATED BY scripts/generate_serialization.py

${INCLUDE_LIST}
namespace duckdb {
'''

footer = '''
} // namespace duckdb
'''

serialize_base = '''
void ${CLASS_NAME}::FormatSerialize(FormatSerializer &serializer) const {
${MEMBERS}}
'''

serialize_element = '\tserializer.WriteProperty("${PROPERTY_KEY}", ${PROPERTY_NAME});\n'

deserialize_base = '''
unique_ptr<${BASE_CLASS_NAME}> ${CLASS_NAME}::FormatDeserialize(${EXTRA_PARAMETERS}FormatDeserializer &deserializer) {
${MEMBERS}
}
'''

switch_code = '''\tswitch (${SWITCH_VARIABLE}) {
${CASE_STATEMENTS}\tdefault:
\t\tthrow SerializationException("Unsupported type for deserialization!");
\t}
'''

switch_statement = '''\tcase ${ENUM_TYPE}::${ENUM_VALUE}:
\t\tresult = ${CLASS_DESERIALIZE}::FormatDeserialize(${EXTRA_PARAMETERS}deserializer);
\t\tbreak;
'''

deserialize_element = '\tauto ${PROPERTY_NAME} = deserializer.ReadProperty<${PROPERTY_TYPE}>("${PROPERTY_KEY}");\n'

# 	auto expression_class = deserializer.ReadProperty<ExpressionClass>("class");
# 	auto type = deserializer.ReadProperty<ExpressionType>("type");
# 	auto alias = deserializer.ReadProperty<string>("alias");
# 	unique_ptr<ParsedExpression> result;
# 	switch (expression_class) {
# 	case ExpressionClass::BETWEEN:
# 		result = BetweenExpression::FormatDeserialize(type, deserializer);
# 		break;

move_list = [
    'string', 'ParsedExpression*'
]

with open(target_path, 'w+') as f:
    f.write(header.replace('${INCLUDE_LIST}', ''.join([include_base.replace('${FILENAME}', x) for x in include_list])))

    # generate the base class serialization
    base_class_serialize = ''
    base_class_deserialize = ''

    # properties
    for entry in serialize_data[base_class]:
        property_name = entry['property'] if 'property' in entry else entry['name']
        base_class_serialize += serialize_element.replace('${PROPERTY_NAME}', property_name).replace('${PROPERTY_KEY}', entry['name'])
        base_class_deserialize += deserialize_element.replace('${PROPERTY_NAME}', property_name).replace('${PROPERTY_TYPE}', entry['type']).replace('${PROPERTY_KEY}', entry['name'])
    expressions = [x for x in base_class_data[base_class_name].items() if x[0] != '__enum_value']
    expressions = sorted(expressions, key=lambda x: x[0])

    base_class_deserialize += f'\tunique_ptr<{base_class_name}> result;\n'
    switch_cases = ''
    extra_parameter_txt = ''
    for extra_parameter in extra_parameters:
        extra_parameter_txt += extra_parameter + ', '
    for expr in expressions:
        switch_cases += switch_statement.replace('${ENUM_TYPE}', 'ExpressionClass').replace('${ENUM_VALUE}', expr[0]).replace('${CLASS_DESERIALIZE}', expr[1]).replace('${EXTRA_PARAMETERS}', extra_parameter_txt)

    assign_entries = []
    for entry in  serialize_data[base_class]:
        entry_name = entry['name']
        entry_property = entry_name
        if 'property' in entry:
            entry_property = entry['property']
        skip = False
        for check_entry in [entry_name, entry_property]:
            if check_entry in extra_parameter:
                skip = True
            if check_entry == base_class_data[base_class_name]['__enum_value']:
                skip = True
        if skip:
            continue
        move = False
        if entry['type'] in move_list:
            move = True
        assign_entries.append([entry_property, move])

    # class switch statement
    base_class_deserialize += switch_code.replace('${SWITCH_VARIABLE}', base_class_data[base_class_name]['__enum_value']).replace('${CASE_STATEMENTS}', switch_cases)

    for entry in assign_entries:
        name = entry[0]
        move = entry[1]
        if move:
            base_class_deserialize+= f'\tresult->{name} = std::move({name});\n'
        else:
            base_class_deserialize+= f'\tresult->{name} = {name};\n'
    base_class_deserialize += '\treturn result;\n'
    base_class_generation = ''
    base_class_generation += serialize_base.replace('${BASE_CLASS_NAME}', base_class_name).replace('${CLASS_NAME}', base_class_name).replace('${MEMBERS}', base_class_serialize)
    base_class_generation += deserialize_base.replace('${BASE_CLASS_NAME}', base_class_name).replace('${CLASS_NAME}', base_class_name).replace('${MEMBERS}', base_class_deserialize).replace('${EXTRA_PARAMETERS}', '')
    f.write(base_class_generation)

    # generate the extra class serialization
    for class_name in class_name_list:
        pass

    f.write(footer)