import os
import re
from pathlib import Path
from typing import Set, List
from functools import total_ordering

# define file paths and global variables
DUCKDB_DIR = Path(__file__).resolve().parent.parent.parent
DUCKDB_SETTINGS_HEADER_FILE = os.path.join(DUCKDB_DIR, "src/include/duckdb/main", "settings.hpp")
DUCKDB_AUTOGENERATED_SETTINGS_FILE = os.path.join(DUCKDB_DIR, "src/main/settings", "autogenerated_settings.cpp")
DUCKDB_CUSTOM_DEFINED_SETTINGS_FILE = os.path.join(DUCKDB_DIR, "src/main/settings", "custom_settings.cpp")
DUCKDB_SETTINGS_SCOPE_FILE = os.path.join(DUCKDB_DIR, "src/main", "config.cpp")
DUCKDB_SETTINGS_TYPES_FILE = os.path.join(DUCKDB_DIR, "src/include/duckdb/common", "types.hpp")
JSON_PATH = os.path.join(DUCKDB_DIR, "src/common", "settings.json")

# define scope values
VALID_SCOPE_VALUES = ["GLOBAL", "LOCAL", "GLOBAL_LOCAL"]
INVALID_SCOPE_VALUE = "INVALID"

# mappin sql types to cpp # TODO: is the mapping correct?
SQL_TYPES_MAPPING_TO_CPP = {
    "VARCHAR": "string",
    "BOOLEAN": "bool",
    "TINYINT": "int8_t",
    "SMALLINT": "int16_t",
    "INTEGER": "int32_t",
    "BIGINT": "int64_t",
    "DATE": "string",
    "TIME": "string",
    "TIMESTAMP_SEC": "string",
    "TIMESTAMP_MS": "string",
    "TIMESTAMP": "string",
    "TIMESTAMP_NS": "string",
    "DECIMAL": "double",
    "FLOAT": "float",
    "DOUBLE": "double",
    "CHAR": "string",
    "BLOB": "string",
    "INTERVAL": "string",
    "UTINYINT": "uint8_t",
    "USMALLINT": "uint16_t",
    "UINTEGER": "uint32_t",
    "UBIGINT": "uint64_t",
    "TIMESTAMP_TZ": "string",
    "TIME_TZ": "string",
    "BIT": "bool",
    "HUGEINT": "__int128",  # TODO: assuming support for 128-bit integers?
    "POINTER": "void*",
    "VALIDITY": "bool",
    "UUID": "string",
    "STRUCT": "struct",  # TODO: a custom struct definition?
    "LIST": "vector",
    "MAP": "duckdb_map",
    "TABLE": "CustomTableType",
    "ENUM": "enum",
    "AGGREGATE_STATE": "CustomAggregateType",
    "LAMBDA": "function",
    "UNION": "variant",
}


# global Setting structure
@total_ordering
class Setting:
    # track names of written settings to prevent duplicates
    __written_settings: Set[str] = set()

    def __init__(
        self,
        name: str,
        input_type: str,
        scope: str,
        description: str,
        aliases: List[str],
        verification: bool = False,
        auto_generate: bool = True,
    ):
        self.__valid_input_types_list = self.__extract_valid_input_types(DUCKDB_SETTINGS_TYPES_FILE)
        self.name = self._get_valid_name(name)
        self.input_type = self._get_input_type(input_type)
        self.setting_type = self._get_setting_type(input_type)
        self.scope = self._get_valid_scope(scope)
        self.description = description
        self.verification = verification
        self.struct_name = self._get_struct_name()
        self.aliases = self._get_aliases(aliases)
        self.auto_generate = auto_generate

    # define all comparisons to be based on the setting's name attribute
    def __eq__(self, other) -> bool:
        return isinstance(other, Setting) and self.name == other.name

    def __lt__(self, other) -> bool:
        return isinstance(other, Setting) and self.name < other.name

    def __hash__(self) -> int:
        return hash(self.name)

    def __repr__(self):
        return f"struct {self.struct_name} -> {self.name}, {self.type}, {self.scope}, {self.description}, {self.verification}, {self.aliases}"

    # validate setting name for correct format and uniqueness
    def _get_valid_name(self, name: str) -> str:
        if not re.match(r'^[a-zA-Z_][a-zA-Z0-9_]*$', name):
            raise ValueError(f"'{name}' cannot be used as setting name - invalid character")
        if name in Setting.__written_settings:
            raise ValueError(f"'{name}' cannot be used as setting name - already exists")
        Setting.__written_settings.add(name)
        return name

    # ensure the setting scope is valid based on the accepted values
    def _get_valid_scope(self, scope: str) -> str:
        scope = scope.upper()
        if scope in VALID_SCOPE_VALUES:
            return scope
        return INVALID_SCOPE_VALUE

    # validate and return the correct type format
    def _get_input_type(self, type) -> str:
        if type in self.__valid_input_types_list:
            return f"LogicalTypeId::{type}"
        raise ValueError(f"Invalid input type: '{type}'")

    # mapping SQL types to their corresponding cpp types
    def _get_setting_type(self, type) -> str:
        return SQL_TYPES_MAPPING_TO_CPP.get(type.upper(), "UnknownType")

    # validate and return the set of the aliases
    def _get_aliases(self, aliases: List[str]) -> List[str]:
        return [self._get_valid_name(alias) for alias in aliases]

    # generate a function name
    def _get_struct_name(self) -> str:
        camel_case_name = ''.join(word.capitalize() for word in re.split(r'[-_]', self.name))
        if camel_case_name.endswith("Setting"):
            return f"{camel_case_name}"
        return f"{camel_case_name}Setting"

    def __extract_valid_input_types(self, file_path: str) -> List[str]:
        with open(file_path, 'r') as file:
            content = file.read()
        enum_block_match = re.search(r'enum class LogicalTypeId : uint8_t {([^}]*)}', content)
        if not enum_block_match:
            return []
        enum_block = enum_block_match.group(1)
        # regex to find individual LogicalTypeId entries
        return re.findall(r'\b(\w+)\s*=\s*\d+', enum_block)


# this global list (accessible across all files) stores all the settings definitions in the json file
SettingsList: List[Setting] = []


# global method that finds the indexes of a start and an end marker in a file
def find_start_end_indexes(source_code, start_marker, end_marker, file_path):
    start_matches = list(re.finditer(start_marker, source_code))
    if len(start_matches) == 0:
        raise ValueError(f"Couldn't find start marker in {file_path}")
    elif len(start_matches) > 1:
        raise ValueError(f"Start marker found more than once in {file_path}")
    start_index = start_matches[0].end()

    end_matches = list(re.finditer(end_marker, source_code[start_index:]))
    if len(end_matches) == 0:
        raise ValueError(f"Couldn't find end marker in {file_path}")
    elif len(end_matches) > 1:
        raise ValueError(f"End marker found more than once in {file_path}")
    end_index = start_index + end_matches[0].start()
    return start_index, end_index


# global method
def write_content_to_file(new_content, path):
    with open(path, 'w') as source_file:
        source_file.write("".join(new_content))
