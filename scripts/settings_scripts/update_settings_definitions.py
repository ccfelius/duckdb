import re
from .config import SettingsList, write_content_to_file, find_start_end_indexes

# markers
START_MARKER = "namespace duckdb {"
END_MARKER = "} // namespace duckdb"
SEPARATOR = "//===----------------------------------------------------------------------===//\n"

implementation_comment = f"\t// Implement the body here\n"


def get_setting_heading(setting_struct_name):
    struct_name_wt_Setting = re.sub(r'Setting$', '', setting_struct_name)
    heading_name = re.sub(r'(?<!^)(?=[A-Z])', ' ', struct_name_wt_Setting)
    heading = SEPARATOR + f"// {heading_name}\n" + SEPARATOR
    return heading


def add_autogenerated_global_functions(setting):
    cpp_code = f"void {setting.struct_name}::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {{\n"
    if setting.add_verification_in_SET:
        cpp_code += f"\tif (!{setting.struct_name}::VerifyDBInstanceSET(db, config, input)) {{\n"
        cpp_code += f"\t\treturn;\n\t}}\n"
    cpp_code += f"\tconfig.options.{setting.name} = input.GetValue<{setting.type}>();\n"
    cpp_code += f"}}\n\n"
    cpp_code += f"void {setting.struct_name}::ResetGlobal(DatabaseInstance *db, DBConfig &config) {{\n"
    if setting.add_verification_in_RESET:
        cpp_code += f"\tif (!{setting.struct_name}::VerifyDBInstanceRESET(db, config)) {{\n"
        cpp_code += f"\t\treturn;\n\t}}\n"
    cpp_code += f"\tconfig.options.{setting.name} = DBConfig().options.{setting.name};\n"
    cpp_code += f"}}\n\n"
    cpp_code += f"Value {setting.struct_name}::GetSetting(const ClientContext &context) {{\n"
    cpp_code += f"\tauto &config = DBConfig::GetConfig(*context.db);\n"
    cpp_code += f"\treturn Value(config.options.{setting.name});\n"  # TODO: ftiakse mia sunarthsh pou na epistrefei to type se zhtoumeno tou Value
    cpp_code += f"}}\n\n"
    return cpp_code


def add_autogenerated_local_functions(setting):
    cpp_code = f"void {setting.struct_name}::SetLocal(ClientContext &context, const Value &input) {{\n"
    if setting.add_verification_in_SET:
        cpp_code += f"\t{setting.struct_name}::VerifyDBInstanceSET(db, config, input);\n"
    cpp_code += (
        f"\tauto &config = ClientConfig::GetConfig(context);\n" f"\tconfig.{setting.name} = input.GetValue<bool>();\n"
    )
    cpp_code += f"}}\n\n"
    cpp_code += f"void {setting.struct_name}::ResetLocal(ClientContext &context) {{\n"
    if setting.add_verification_in_RESET:
        cpp_code += f"\tif (!{setting.struct_name}::VerifyDBInstanceRESET(db, config)) {{\n"
        cpp_code += f"\t\treturn;\n\t}}\n"
    cpp_code += f"\tClientConfig::GetConfig(context).{setting.name} = ClientConfig().{setting.name};\n"
    cpp_code += f"}}\n\n"
    cpp_code += f"Value {setting.struct_name}::GetSetting(const ClientContext &context) {{\n"
    cpp_code += f"\tauto &config = DBConfig::GetConfig(*context.db);\n"
    cpp_code += f"\treturn Value(config.{setting.name});\n"
    cpp_code += f"}}\n\n"
    return cpp_code


def add_autogenerated_functions(path):
    with open(path, 'r') as source_file:
        source_code = source_file.read()

    # find start and end indexes of the auto-generated section
    start_index, end_index = find_start_end_indexes(source_code, START_MARKER, END_MARKER, path)

    # split source code into sections
    start_section = source_code[: start_index + 1] + "\n"
    end_section = source_code[end_index:]

    new_content = ""
    added = 0
    for setting in SettingsList:
        if not setting.custom_value_conversion:
            new_content += get_setting_heading(setting.struct_name)
            if setting.scope == "GLOBAL" or setting.scope == "GLOBAL_LOCAL":
                new_content += add_autogenerated_global_functions(setting)
            if setting.scope == "LOCAL" or setting.scope == "GLOBAL_LOCAL":
                new_content += add_autogenerated_local_functions(setting)
            added += 1
    return start_section + new_content + end_section, added


def find_missing_settings(existing_settings):
    missing_settings = {
        setting.struct_name: setting for setting in SettingsList if setting.struct_name not in existing_settings.keys()
    }
    return missing_settings


# TODO: vale to verify poy gurnaei true or false na to kanei kati - an pairnei false na kanei return !!!!! e.g. des l.77 custom_settings
def is_seperator(line):
    if SEPARATOR in line:
        return True
    return False


def is_namespace_end_pattern(line):
    if "} // namespace duckdb" in line:
        return True
    return False


def find_existing_settings_dict(custom_settings_path):
    settings_dict = {}
    current_setting = None
    with open(custom_settings_path, 'r') as file:
        lines = file.readlines()
        for line_num, line in enumerate(lines):
            if is_seperator(line) and is_seperator(lines[line_num + 2]):
                if current_setting is not None:
                    settings_dict[current_setting]['end_line'] = line_num - 1

                # start a new setting
                current_setting = lines[line_num + 1].removeprefix("//").removesuffix("\n").replace(' ', '') + "Setting"
                settings_dict[current_setting] = {'start_line': line_num, 'end_line': None}

            # check if the line indicates the end of the namespace
            if is_namespace_end_pattern(line):
                if current_setting is not None:
                    settings_dict[current_setting]['end_line'] = line_num - 1
                break  # stop parsing as we reached the end of the namespace
    return settings_dict


def get_set_custom_funcs(scope, setting):
    new_setting = (
        f"void {setting.struct_name}::Set{scope}(DatabaseInstance *db, DBConfig &config, const Value &input) {{\n"
    )
    new_setting += implementation_comment + "}\n\n"
    new_setting += f"void {setting.struct_name}::Reset{scope}(DatabaseInstance *db, DBConfig &config) {{\n"
    new_setting += implementation_comment + "}\n\n"
    return new_setting


def get_new_setting_def(setting):
    new_setting = ""
    if setting.add_verification_in_SET:
        new_setting += f"bool {setting.struct_name}::VerifyDBInstanceSET(DatabaseInstance *db, DBConfig &config, const Value &input) {{\n"
        new_setting += implementation_comment + "}\n\n"
    if setting.add_verification_in_RESET:
        new_setting += f"bool {setting.struct_name}::VerifyDBInstanceRESET(DatabaseInstance *db, DBConfig &config) {{\n"
        new_setting += implementation_comment + "}\n\n"
    if setting.scope == "GLOBAL" or setting.scope == "GLOBAL_LOCAL":
        new_setting += get_set_custom_funcs("Global", setting)
    if setting.scope == "LOCAL" or setting.scope == "GLOBAL_LOCAL":
        new_setting += get_set_custom_funcs("Local", setting)
    new_setting += f"Value {setting.struct_name}::GetSetting(const ClientContext &context) {{\n"
    new_setting += implementation_comment + "}\n\n"
    return new_setting


def create_content_for_custom_funcs(custom_settings_path, existing_settings, missing_settings):
    keys1 = list(existing_settings.keys())
    keys2 = list(missing_settings.keys())
    combined_keys = sorted(keys1 + keys2)

    with open(custom_settings_path, 'r') as source_file:
        lines = source_file.readlines()

    new = 0
    old = 0
    new_content = ""
    for struct_name in combined_keys:
        if struct_name in missing_settings:
            setting = missing_settings[struct_name]
            if setting.add_verification_in_SET or setting.add_verification_in_RESET or setting.custom_value_conversion:
                new_content += get_setting_heading(setting.struct_name)
                new += 1
            if setting.add_verification_in_SET:
                new_content += f"bool {setting.struct_name}::VerifyDBInstanceSET(DatabaseInstance *db, DBConfig &config, const Value &input) {{\n"
                new_content += implementation_comment + "}\n\n"
            if setting.add_verification_in_RESET:
                new_content += (
                    f"bool {setting.struct_name}::VerifyDBInstanceRESET(DatabaseInstance *db, DBConfig &config) {{\n"
                )
                new_content += implementation_comment + "}\n\n"
            if setting.custom_value_conversion:
                new_content += get_new_setting_def(setting)
        else:
            start_line = existing_settings[struct_name]['start_line']
            end_line = existing_settings[struct_name]['end_line']
            new_content += "".join(lines[start_line:end_line]) + "\n"
            old += 1
    return new_content, new, old


def add_custom_functions(custom_settings_path):
    existing_settings = find_existing_settings_dict(custom_settings_path)
    missing_settings = find_missing_settings(existing_settings)

    with open(custom_settings_path, 'r') as source_file:
        source_code = source_file.read()

    # split source code into sections
    start_index, end_index = find_start_end_indexes(source_code, START_MARKER, END_MARKER, custom_settings_path)
    start_section = source_code[: start_index + 1] + "\n"
    end_section = source_code[end_index:]

    new_content, new, old = create_content_for_custom_funcs(custom_settings_path, existing_settings, missing_settings)
    return start_section + new_content + end_section, new, old


def generate():
    from .config import DUCKDB_AUTOGENERATED_SETTINGS_FILE, DUCKDB_CUSTOM_DEFINED_SETTINGS_FILE

    print(f"Updating {DUCKDB_AUTOGENERATED_SETTINGS_FILE}")
    new_autogenerated_content, generated = add_autogenerated_functions(DUCKDB_AUTOGENERATED_SETTINGS_FILE)
    write_content_to_file(new_autogenerated_content, DUCKDB_AUTOGENERATED_SETTINGS_FILE)

    # NOTE: if you want to disable the addition of new_content for each new setting in custom_settings.cpp, comment out the following code
    print(f"Updating {DUCKDB_CUSTOM_DEFINED_SETTINGS_FILE}")
    new_content, added_custom, existing_custom = add_custom_functions(DUCKDB_CUSTOM_DEFINED_SETTINGS_FILE)
    write_content_to_file(new_content, DUCKDB_CUSTOM_DEFINED_SETTINGS_FILE)

    # for debugging purposes
    # print(f"The total number of settings is {len(SettingsList)}, and {generated} settings are added in {DUCKDB_AUTOGENERATED_SETTINGS_FILE} and, {added_custom} new and {existing_custom} existing added in {DUCKDB_CUSTOM_DEFINED_SETTINGS_FILE}")


if __name__ == '__main__':
    raise ValueError("Please use 'generate_settings.py' instead of running the individual script(s)")
